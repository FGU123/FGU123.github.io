<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="ppxu&#39;s blog">
  <meta name="keyword" content="java, blog, article">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      RocketMQ相关总结 | PPXu
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PPXu</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/search" class="item-link">Search</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/search" class="menu-link">Search</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RocketMQ相关总结</h2>
  <p class="post-date">2018-11-18</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>总结RocketMQ相关知识点，便于回顾记忆…</p>
<h2 id="Rocket官网地址"><a href="#Rocket官网地址" class="headerlink" title="Rocket官网地址"></a>Rocket官网地址</h2><p><a href="https://rocketmq.incubator.apache.org/" target="_blank" rel="noopener">https://rocketmq.incubator.apache.org/</a></p>
<h2 id="RocketMQ总体特点"><a href="#RocketMQ总体特点" class="headerlink" title="RocketMQ总体特点"></a>RocketMQ总体特点</h2><ol>
<li><p>能够保证严格的消息顺序</p>
</li>
<li><p>提供丰富的消息拉取模式</p>
</li>
<li><p>高效的订阅者水平扩展能力</p>
</li>
<li><p>实时的消息订阅机制</p>
</li>
<li><p>亿级消息堆积能力</p>
</li>
</ol>
<h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>主要以commitLog为消息存储的数据结构。<br><img src="/images/post-RocketMQ-Summary/20160627161734720.jpg" alt=""></p>
<p><img src="/images/post-RocketMQ-Summary/20160627161750955.jpg" alt=""></p>
<p>（1）所有数据单独储存到commit Log ，完全顺序写，随机读</p>
<p>（2）对最终用户展现的队列实际只储存消息在Commit Log 的位置信息，并且串行方式刷盘</p>
<p>（3）按照MessageId查询消息</p>
<p><img src="/images/post-RocketMQ-Summary/20160627161909644.jpg" alt=""></p>
<p>（4）根据查询的key的hashcode%slotNum得到具体的槽位置</p>
<p><img src="/images/post-RocketMQ-Summary/20160627162003737.jpg" alt=""></p>
<p>（5）根据slotValue（slot对应位置的值）查找到索引项列表的最后一项</p>
<p>（6）遍历索引项列表返回查询时间范围内的结果集</p>
<h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p><img src="/images/post-RocketMQ-Summary/20181118164510.jpg" alt=""><br>作为一款纯 Java 语言开发的消息引擎，RocketMQ 自主研发的存储组件，依赖 Page Cache 进行加速和堆积，意味着它的性能会受到 JVM、 GC、内核、Linux 内存管理机制、文件 IO 等因素的影响。Rocketmq中的所有消息都是持久化到硬盘的，但会使用系统PageCache加速访问，消息的落地方式是先写PageCache后刷盘，可以保证内存与磁盘都有一份数据，访问时，可以直接从内存读取。如图所示，一条消息从客户端发送出，到最终落盘持久化，每个环节都有产生延迟的风险。</p>
<blockquote>
<p>《不一样的技术创新-阿里巴巴2016双十一背后的技术》一书中提到，有线上数据显示，RocketMQ 写消息链路存在偶发的高达数秒的延迟</p>
</blockquote>
<ul>
<li><p><strong>同步刷盘</strong><br>同步刷盘是指，broker在收到每个消息后，都是先要保存到硬盘上，然后再给producer确认。</p>
</li>
<li><p><strong>异步刷盘</strong><br>异步刷盘就是先回复确认，然后批量保存到硬盘上。异步刷盘有更好的性能，当然也有更大的丢失消息的风险。</p>
</li>
</ul>
<h2 id="角色关系图"><a href="#角色关系图" class="headerlink" title="角色关系图"></a>角色关系图</h2><p><img src="/images/post-RocketMQ-Summary/20181118155237.jpg" alt=""></p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/post-RocketMQ-Summary/20160629175853107.jpg" alt=""></p>
<h3 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h3><p>所有的集群都具有水平扩展能力，无单点障碍。<br><br></p>
<ul>
<li>NameServer以轻量级的方式提供服务发现和路由功能，每个NameServer存有全量的路由信息，提供对等的读写服务，是一个几乎无状态节点，可集群部署，节点之间无任何信息同步，支持快速扩缩容。<br><br></li>
<li>Broker为实际的消息队列服务器(MQ Server)，在整体架构中，可以看作是Producer与Comsumer之间的驳脚者，消息通过它从Producer接收，并存储，后转发给Consumer。以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型，具备多副本容错机制（2副本或3副本）、强大的削峰填谷以及上亿级消息堆积能力，同时可严格保证消息的有序性。<blockquote>
<p>除此之外，Broker还提供了同城异地容灾能力，丰富的Metrics统计以及告警机制。这些都是传统消息系统无法比拟的。</p>
</blockquote>
</li>
<li>Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。</li>
<li>Consumer也由用户部署，支持PUSH和PULL两种消费模式（推模式的实现也是用的拉方式），支持集群消费和广播消息，提供实时的消息订阅机制，满足大多数消费场景。</li>
</ul>
<h2 id="RocketMQ亮点-支持多种消费模式"><a href="#RocketMQ亮点-支持多种消费模式" class="headerlink" title="RocketMQ亮点-支持多种消费模式"></a>RocketMQ亮点-支持多种消费模式</h2><p>RocketMQ最初还未正式称为RocketMQ，一开始v1.0还是叫metaQ，经历了3代的重要演进，v3.0开始改名RocketMQ，其重要改进包括消息获取模式。<br><br></p>
<ol>
<li>第一代，推模式，数据存储采用关系型数据库。在这种模式下，消息具有很低的延迟特性，并且很容易支持分布式事务。尤其在阿里淘宝这种高频交易场景中，具有非常广泛地应用。典型代表包括Notify、Napoli。</li>
<li>第二代，拉模式，自研的专有消息存储。在日志处理方面能够媲美Kafka的吞吐性能，但考虑到淘宝的应用场景，尤其是其交易链路的高可靠需求，消息引擎并没有一味的追求吞吐，而是将稳定可靠放在首位。因为采用了长连接拉模式，在消息的实时方面丝毫不逊推模式。典型代表MetaQ。</li>
<li>第三代，以拉模式为主，兼有推模式的高性能、低延迟消息引擎RocketMQ，在二代功能特性的基础上，为电商金融领域添加了可靠重试、基于文件存储的分布式事务等特性，并做了大量优化。从2012年开始，经历了历次双11核心交易链路检验。目前已经捐赠给Apache基金会。</li>
</ol>
<p>不难看出，RocketMQ其实是伴随着阿里巴巴整个生态的成长，逐渐衍生出来的高性能，高可用，兼具高吞吐量和低延迟、能够同时满足电商领域和金融领域的极尽苛刻场景的消息中间件。</p>
<h2 id="Broker部署方式"><a href="#Broker部署方式" class="headerlink" title="Broker部署方式"></a>Broker部署方式</h2><h3 id="单Master"><a href="#单Master" class="headerlink" title="单Master"></a>单Master</h3><blockquote>
<p>这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。</p>
</blockquote>
<h3 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h3><p>多台Broker，全是Master</p>
<blockquote>
<p>优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。<br>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p>
</blockquote>
<h3 id="HA方案：多Master-Slave对模式"><a href="#HA方案：多Master-Slave对模式" class="headerlink" title="HA方案：多Master/Slave对模式"></a>HA方案：多Master/Slave对模式</h3><p>每个 Master 配对一个 Slave，有多对Master-Slave。</p>
<h4 id="Master-Slave复制方式"><a href="#Master-Slave复制方式" class="headerlink" title="Master/Slave复制方式"></a>Master/Slave复制方式</h4><ul>
<li><p>同步双写<br>写入消息时，master先写入，之后复制到slave，确认slave也存储了消息后才向producer答复返回成功。</p>
<blockquote>
<p>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高<br>缺点：性能比异步复制模式略低，大约低10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p>
</blockquote>
</li>
<li><p>异步复制<br>先答复producer，再去向salve复制。</p>
<blockquote>
<p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。<br>缺点：Master宕机，磁盘损坏情况，会丢失少量消息。</p>
</blockquote>
</li>
</ul>
<p>通过同步复制技术可以完全避免单点，同步复制势必会影响性能，适合应用于消息可靠性要求极高的场合。RocketMQ从3.0版本开始支持同步双写。</p>
<h2 id="两种消息消费的交互方式的区别"><a href="#两种消息消费的交互方式的区别" class="headerlink" title="两种消息消费的交互方式的区别"></a>两种消息消费的交互方式的区别</h2><p>留意源码可以得知：<br>consumer被分为2类：MQPullConsumer和MQPushConsumer，本质都是拉模式（pull），即consumer轮询从broker拉取消息。<br>区别在于：</p>
<ul>
<li><p>push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对客户端而言，感觉消息是被推送（push）过来的。</p>
</li>
<li><p>pull方式里，取消息的过程，RocketMQ交给了用户自己实现，首先通过待消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Java缓存  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; offseTable = <span class="keyword">new</span> HashMap&lt;MessageQueue, Long&gt;();  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String nameServAndAddr = <span class="string">"172.16.235.77:9876;172.16.235.78:9876"</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumerGroupName =<span class="string">"ConsumerGroupName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumber =<span class="string">"Consumber"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 主动拉取方式消费 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MQClientException </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 一个应用创建一个Consumer，由应用来维护此对象，可以设置为全局对象或者单例&lt;br&gt; </span></span><br><span class="line"><span class="comment">         * 注意：ConsumerGroupName需要由应用来保证唯一 ,最好使用服务的包名区分同一服务,一类Consumer集合的名称， </span></span><br><span class="line"><span class="comment">         * 这类Consumer通常消费一类消息，且消费逻辑一致 </span></span><br><span class="line"><span class="comment">         * PullConsumer：Consumer的一种，应用通常主动调用Consumer的拉取消息方法从Broker拉消息，主动权由应用控制 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(consumerGroupName);  </span><br><span class="line">        <span class="comment">// //nameserver服务  </span></span><br><span class="line">        consumer.setNamesrvAddr(nameServAndAddr);  </span><br><span class="line">        consumer.setInstanceName(consumber);  </span><br><span class="line">        consumer.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 拉取订阅主题的队列，默认队列大小是4  </span></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">"TopicTest1"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Consume from the queue: "</span> + mq);  </span><br><span class="line">            SINGLE_MQ: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    PullResult pullResult = </span><br><span class="line">                consumer.pullBlockIfNotFound(</span><br><span class="line">                        mq, <span class="keyword">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);  </span><br><span class="line">                    List&lt;MessageExt&gt; list = pullResult.getMsgFoundList();  </span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &lt; <span class="number">100</span>) &#123;  </span><br><span class="line">                        <span class="keyword">for</span> (MessageExt msg : list) &#123;  </span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(msg.getBody()));  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    System.out.println(pullResult.getNextBeginOffset());  </span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());  </span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:  </span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;  </span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">default</span>:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        consumer.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset)</span> </span>&#123;  </span><br><span class="line">        offseTable.put(mq, offset);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> </span>&#123;  </span><br><span class="line">        Long offset = offseTable.get(mq);  </span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(offset);  </span><br><span class="line">            <span class="keyword">return</span> offset;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push</p>
</blockquote>
<p>长轮询Pull：<br>建立长连接，每隔一定时间，客户端向服务端发起请求询问数据，如有则返回数据，如无则返回空，然后关闭请求。<br>长轮询与普通轮询的不同之处在于，哪怕服务端此时没有数据，连接还是保持的，等到有数据时可以立即返回（也就模拟push），或者超时返回。<br>长轮询好处在于可以减少无效请求，保证消息实时性获取，又不会造成积压。</p>
<blockquote>
<p>推拉模式的具体选取视乎实际情况而定，在一些离线大批量数据处理系统中，消息获取的需求强调的更多是吞吐量，而非低延迟，此时拉模式可能更优。</p>
</blockquote>
<h2 id="RocketMQ-高可用保障"><a href="#RocketMQ-高可用保障" class="headerlink" title="RocketMQ 高可用保障"></a>RocketMQ 高可用保障</h2><p>通过可用性计算公式可以看出，要提升系统的可用性，需要在保障系统健壮性以延长平均无故障时间的基础上，进一步加强系统的故障自动恢复能力以缩短平均故障修复时间。 RocketMQ 高可用架构设计并实现了 Controller 组件，按照单主状态、异步复制状态、半同步状态以及最终的同步复制状态的有限状态机进行转换。在最终的同步复制状态下，Master 和 Slave 任一节点故障时，其它节点能够在秒级时间内切换到单主状态继续提供服务。相比于之前人工介入重启来恢复服务，RokcetMQ 高可用架构赋予了系统故障自动恢复的能力，能极大缩短平均故障恢复时间，提升系统的可用性。</p>
<p>下图描述了 RocketMQ 高可用架构中有限状态机的转换：</p>
<p><img src="/images/post-RocketMQ-Summary/20181118180808.jpg" alt=""></p>
<p>1） 第一个节点启动后，Controller 控制状态机切换为单主状态，通知启动节点以 Master 角色提供服务。<br>2） 第二个节点启动后， Controller 控制状态机切换成异步复制状态。Master 通过异步方式向 Slave 复制数据。<br>3） 当 Slave 的数据即将赶上 Master，Controller 控制状态机切换成半同步状态，此时命中 Master 的写请求会被 Hold 住，直到 Master以异步方式向 Slave 复制了所有差异的数据。<br>4） 当半同步状态下 Slave 的数据完全赶上 Master 时，Controller控制状态机切换成同步复制模式，Mater 开始以同步方式向 Slave 复制数据。该状态下任一节点出现故障，其它节点能够在秒级内切换到单主状态继续提供服务。<br>Controller 组件控制 RocketMQ 按照单主状态，异步复制状态，半同步状态，同步复制状态的顺序进行状态机切换。中间状态的停留时间与主备之间的数据差异以及网络带宽有关，但最终都会稳定在同步复制状态下。</p>
<h2 id="如何保证消息有序消费？"><a href="#如何保证消息有序消费？" class="headerlink" title="如何保证消息有序消费？"></a>如何保证消息有序消费？</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照这个顺序消费才有意义。但同时订单之间又是可以并行消费的。</p>
<p>假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：<br><img src="/images/post-RocketMQ-Summary/20160628162759326.jpg" alt=""></p>
<p>M1发送到S1后，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端后，通知S2，然后S2再将M2发送到消费端。</p>
<p>这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到，也就不能保证M1被先消费，那么就需要在MQ Server集群维护消息的顺序。那么如何解决？一种简单的方式就是将M1、M2发送到同一个Server上：<br><img src="/images/post-RocketMQ-Summary/20160628163033073.jpg" alt=""></p>
<p>这样可以保证M1先于M2到达MQServer（客户端等待M1成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。</p>
<p>这个模型，理论上可以保证消息的顺序，但在实际运用中你应该会遇到下面的问题：<br><img src="/images/post-RocketMQ-Summary/20160628163128871.jpg" alt=""></p>
<p>只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就先被消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费。如何解决这个问题？将M1和M2发往同一个消费者即可，且发送M1后，需要消费端响应成功后才能发送M2。</p>
<p>但又会引入另外一个问题，如果发送M1后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。</p>
<p><img src="/images/post-RocketMQ-Summary/20160628163222107.jpg" alt=""></p>
<p>这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达，另外一种情况是消费端1已经响应，但是Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就是我们后面要说的第二个问题，消息重复问题。</p>
<p>回过头来看消息顺序问题，严格的顺序消息非常容易理解，而且处理问题也比较容易，要实现严格的顺序消息，简单且可行的办法就是：</p>
<blockquote>
<p>保证生产者 - MQServer - 消费者是一对一对一的关系</p>
</blockquote>
<p>但是这样设计，并行度就成为了消息系统的瓶颈（吞吐量不够），也会导致更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</p>
<p>但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？</p>
<p>有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决它们身上，实际上是浪费的，效率低下的。从这个角度来看消息的顺序问题，我们可以得出两个结论：</p>
<blockquote>
<ol>
<li>不关注乱序的应用实际大量存在 </li>
<li>队列无序并不意味着消息无序</li>
</ol>
</blockquote>
<p>最后我们从源码角度分析RocketMQ怎么实现发送顺序消息。</p>
<p>一般消息是通过轮询所有队列来发送的（负载均衡策略），顺序消息可以根据业务，比如说订单号相同的消息发送到同一个队列。下面的示例中，OrderId相同的消息，会发送到同一个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash</span></span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        Integer id = (Integer) arg;</span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, orderId);</span><br></pre></td></tr></table></figure>
<p>在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的队列是同一个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">send</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 获取topic路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据我们的算法，选择一个发送队列</span></span><br><span class="line">        <span class="comment">// 这里的arg = orderId</span></span><br><span class="line">        mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">        <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消息重复–如何保证幂等性"><a href="#消息重复–如何保证幂等性" class="headerlink" title="消息重复–如何保证幂等性"></a>消息重复–如何保证幂等性</h2><p>上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</p>
<p>造成消息的重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是不解决，转而绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<blockquote>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性 </li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
</blockquote>
<p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p>
<p>我们可以看到第1条的解决方式，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率不一定大，且由消息系统实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p>
<p>RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</p>
<p>在单机环境下，执行事务的情况，大概是下面这个样子：<br><img src="/images/post-RocketMQ-Summary/20160628163613018.jpg" alt=""></p>
<p>当用户增长到一定程度，Bob和Smith的账户及余额信息已经不在同一台服务器上了，那么上面的流程就变成了这样：<img src="/images/post-RocketMQ-Summary/20160628164422155.jpg" alt=""></p>
<p>这时候你会发现，同样是一个转账的业务，在集群环境下，耗时居然成倍的增长，这显然是不能够接受的。那我们如何来规避这个问题？</p>
<blockquote>
<p>大事务 = 小事务 + 异步</p>
</blockquote>
<p>将大事务拆分成多个小事务异步执行。这样基本上能够将跨机事务的执行效率优化到与单机一致。转账的事务就可以分解成如下两个小事务：</p>
<p><img src="/images/post-RocketMQ-Summary/20160628164504397.jpg" alt=""></p>
<p>图中执行本地事务（Bob账户扣款）和发送异步消息应该保持同时成功或者失败中，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？</p>
<p>首先我们看下，先发送消息，大致的示意图如下：<br><img src="/images/post-RocketMQ-Summary/20160628164545475.jpg" alt=""></p>
<p>存在的问题是：如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。</p>
<p>先发消息不行，那我们就先扣款呗，大致的示意图如下：<br><img src="/images/post-RocketMQ-Summary/20160628164625033.jpg" alt=""></p>
<p>存在的问题跟上面类似：如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。</p>
<p>可能大家会有很多的方法来解决这个问题，比如：直接将发消息放到Bob扣款的事务中去，如果发送失败，抛出异常，事务回滚。这样的处理方式也符合“恰好”不需要解决的原则。RocketMQ支持事务消息，下面我们来看看RocketMQ是怎样来实现的。</p>
<p><img src="/images/post-RocketMQ-Summary/20160628164703038.jpg" alt=""></p>
<p>RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。细心的你可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，这时候发现了Prepared消息，它会向消息发送者确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<p>那我们来看下RocketMQ源码，是不是这样来处理事务消息的。客户端发送事务消息的部分（完整代码请查看：rocketmq-example工程下的com.alibaba.rocketmq.example.transaction.TransactionProducer）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 未决事务，MQ服务器回查客户端</span></span><br><span class="line"><span class="comment">// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务</span></span><br><span class="line">TransactionCheckListener transactionCheckListener = <span class="keyword">new</span> TransactionCheckListenerImpl();</span><br><span class="line"><span class="comment">// 构造事务消息的生产者</span></span><br><span class="line">TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"groupName"</span>);</span><br><span class="line"><span class="comment">// 设置事务决断处理类</span></span><br><span class="line">producer.setTransactionCheckListener(transactionCheckListener);</span><br><span class="line"><span class="comment">// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑</span></span><br><span class="line">TransactionExecuterImpl tranExecuter = <span class="keyword">new</span> TransactionExecuterImpl();</span><br><span class="line">producer.start()</span><br><span class="line"><span class="comment">// 构造MSG，省略构造参数</span></span><br><span class="line">Message msg = <span class="keyword">new</span> Message(......);</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line">SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, <span class="keyword">null</span>);</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<p>接着查看sendMessageInTransaction方法的源码，总共分为3个阶段：发送Prepared消息、执行本地事务、发送确认消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(.....)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑代码，非实际代码</span></span><br><span class="line">    <span class="comment">// 1.发送消息</span></span><br><span class="line">    sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">    <span class="comment">// sendResult.getSendStatus() == SEND_OK</span></span><br><span class="line">    <span class="comment">// 2.如果消息发送成功，处理与消息关联的本地事务单元</span></span><br><span class="line">    LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">    <span class="comment">// 3.结束事务</span></span><br><span class="line">    <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>endTransaction方法会将请求发往broker(mq server)去更新事物消息的最终状态：</p>
<blockquote>
<ol>
<li>根据sendResult找到Prepared消息</li>
<li>根据localTransaction更新消息的最终状态</li>
</ol>
</blockquote>
<p>如果endTransaction方法执行失败，导致数据没有发送到broker，broker会有回查线程定时（默认1分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是prepared状态则会向Producer发起CheckTransaction请求，Producer会调用DefaultMQProducerImpl.checkTransactionState()方法来处理broker的定时回调请求，而checkTransactionState会调用我们的事务设置的决断方法，最后调用endTransactionOneway让broker来更新消息的最终状态。</p>
<p>再回到转账的例子，如果Bob的账户的余额已经减少，且消息已经发送成功，Smith端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题？解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。</p>
<p><img src="/images/post-RocketMQ-Summary/20160628164932959.jpg" alt=""></p>
<p>这样基本上可以解决超时问题，但是如果消费失败怎么办？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因Smith加款失败，需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<blockquote>
<p>在3.2.6版本中移除了事务消息的实现，所以此版本不支持事务消息，具体情况请参考rocketmq的issues：<br><a href="https://github.com/alibaba/RocketMQ/issues/65" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/65</a><br><a href="https://github.com/alibaba/RocketMQ/issues/138" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/138</a><br><a href="https://github.com/alibaba/RocketMQ/issues/156" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/156</a></p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p>《不一样的技术创新-阿里巴巴2016双十一背后的技术》</p>
</li>
<li><p><a href="https://www.jianshu.com/p/66edd4f99e3c" target="_blank" rel="noopener">RocketMq知识点理解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/asdf08442a/article/details/54882769" target="_blank" rel="noopener">RocketMQ总结整理</a></p>
</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#消息队列" >
    <span class="tag-code">消息队列</span>
  </a>

  <a href="/tags#分布式" >
    <span class="tag-code">分布式</span>
  </a>

  <a href="/tags#异步" >
    <span class="tag-code">异步</span>
  </a>

  <a href="/tags#削峰" >
    <span class="tag-code">削峰</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/11/05/ThreadLocal-Summary/">
        <span class="nav-arrow">← </span>
        
          总结ThreadLocal
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <!--<div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>-->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Rocket官网地址"><span class="toc-nav-text">Rocket官网地址</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RocketMQ总体特点"><span class="toc-nav-text">RocketMQ总体特点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#核心原理"><span class="toc-nav-text">核心原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#数据结构"><span class="toc-nav-text">数据结构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#刷盘策略"><span class="toc-nav-text">刷盘策略</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#角色关系图"><span class="toc-nav-text">角色关系图</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#架构图"><span class="toc-nav-text">架构图</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#架构特点"><span class="toc-nav-text">架构特点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RocketMQ亮点-支持多种消费模式"><span class="toc-nav-text">RocketMQ亮点-支持多种消费模式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Broker部署方式"><span class="toc-nav-text">Broker部署方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#单Master"><span class="toc-nav-text">单Master</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#多Master模式"><span class="toc-nav-text">多Master模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#HA方案：多Master-Slave对模式"><span class="toc-nav-text">HA方案：多Master/Slave对模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Master-Slave复制方式"><span class="toc-nav-text">Master/Slave复制方式</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#两种消息消费的交互方式的区别"><span class="toc-nav-text">两种消息消费的交互方式的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#RocketMQ-高可用保障"><span class="toc-nav-text">RocketMQ 高可用保障</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#如何保证消息有序消费？"><span class="toc-nav-text">如何保证消息有序消费？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消息重复–如何保证幂等性"><span class="toc-nav-text">消息重复–如何保证幂等性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#事务消息"><span class="toc-nav-text">事务消息</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Reference"><span class="toc-nav-text">Reference</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/11/18/RocketMQ-Summary/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fgu123";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RocketMQ相关总结",
        owner: "fgu123",
        repo: "fgu123.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2018/11/18/RocketMQ-Summary/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>