<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="ppxu&#39;s blog">
  <meta name="keyword" content="java, blog, article">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      AOP | PPXu
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PPXu</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/search" class="item-link">Search</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/search" class="menu-link">Search</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>AOP</h2>
  <p class="post-date">2019-04-22</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>整合总结，备忘…</p>
<h1 id="What’s-AOP"><a href="#What’s-AOP" class="headerlink" title="What’s AOP"></a>What’s AOP</h1><p>Aspect Oriented Programming，面向切面编程。以 OOP 来对比理解：</p>
<p><b>纵向关系 OOP，横向角度 AOP</b></p>
<p></p><p><br>以 日志记录 为例，在没有AOP之前，如果需要在多个方法中进行日志记录，需要在每个方法中都重复编写同一段日志操作代码，哪怕日志操作记录的方法被封装到工具类(LogUtils)，仅需要一行调用即可，这样的操作还是对业务代码有侵入性，而类似日志统计、性能分析等这一类就被称为侵入性业务，使原本的业务逻辑代码跟日志操作这类代码有耦合，并且往往这类代码横跨并嵌入众多模块里边，在各个模块里分散得很厉害，到处都能见到，造成代码维护困难。<br></p><p></p>
<blockquote>
<p>从对象组织角度来讲，我们一般采用的分类方法都是使用类似生物学分类的方法，以「继承」关系为主线，我们称之为纵向，也就是OOP。设计时只使用 OOP思想可能会带来两个问题：</p>
<ul>
<li>对象设计的时候一般都是纵向思维，如果这个时候考虑这些不同类对象的共性，不仅会增加设计的难度和复杂性，还会造成类的接口过多而难以维护（共性越多，意味着接口契约越多）。</li>
<li>需要对现有的对象 动态增加 某种行为或责任时非常困难。<br>而AOP就可以很好地解决以上的问题，怎么做到的？除了这种纵向分类之外，我们从横向的角度去观察这些对象，无需再去到处调用 LogUtils 了，声明哪些地方需要打印日志，这个地方就是一个切面，AOP 会在适当的时机为你把打印语句插进切面。</li>
</ul>
</blockquote>
<p><img src="/images/post-aop/20190422060436.png" alt=""></p>
<h1 id="AOP用处"><a href="#AOP用处" class="headerlink" title="AOP用处"></a>AOP用处</h1><h2 id="参数校验和判空"><a href="#参数校验和判空" class="headerlink" title="参数校验和判空"></a>参数校验和判空</h2><p>系统之间在进行接口调用时，往往是有入参传递的，入参是接口业务逻辑实现的先决条件，有时入参的缺失或错误会导致业务逻辑的异常，大量的异常捕获无疑增加了接口实现的复杂度，也让代码显得雍肿冗长，因此提前对入参进行验证是有必要的，可以提前处理入参数据的异常，并封装好异常转化成结果对象返回给调用方，也让业务逻辑解耦变得独立。</p>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>避免到处都是申请权限和处理权限的代码。</p>
<h2 id="无痕埋点"><a href="#无痕埋点" class="headerlink" title="无痕埋点"></a>无痕埋点</h2><p>围绕方法调用前后进行接口调度次数统计的埋掉操作。</p>
<h2 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h2><p>比如全局的登录状态流程控制。</p>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>常用于方法进入前、执行结果后的日志记录。</p>
<h2 id="性能统计"><a href="#性能统计" class="headerlink" title="性能统计"></a>性能统计</h2><p>检测方法耗时其实已经有一些现成的工具。痛点是这些工具使用起来都比较麻烦，效率低下，而且无法针对某一个块代码或者某个指定的sdk进行查看方法耗时。可以采用 AOP 思想对每个方法做一个切点，在执行之后打印方法耗时。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>声明方法，为特定方法加上事务，指定情况下（比如抛出异常）回滚事务。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>替代防御性的 try-Catch。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。留意一些常用的缓存框架的使用方式，即可发现AOP的应用，譬如guava cache/caffeine，可以在真实的DAO方法前冠上@Cacheable便可以指定方法返回值来被缓存。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式又分<b>静态代理</b>与<b>动态代理。</b></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote>
<p>代理模式上，基本上有Subject角色，RealSubject角色，Proxy角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。</p>
</blockquote>
<p><img src="/images/post-aop/‎20190‎4‎‎24‎‏‎55910.png" alt=""></p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>通常，我们会使用代理模式来实现 AOP，这就意味着代理模式可以优雅的解决侵入性业务问题。之所以优雅，其中一个点就在于，「动态」二字。较之静态，动态就体现出更加灵活，在运行时动态地对某些东西代理，代理它去做了一些其他的事情。这种动态依赖的是反射机制。因为静态代理需要预先定义好代理类的代码实现，而当大量使用静态代理时，就可能产生大量的代理类，随着类的数量及规模增大，代码维护成本也随之增大，为了解决这个问题，就有了动态地创建代理类的想法。<br><br><br>在运行期的代码中生成二进制字节码</p>
<blockquote>
<p>由于JVM通过字节码的二进制信息加载类的，那么，如果我们在运行期系统中，遵循Java编译系统组织.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类，这样，就完成了在代码中，动态创建一个类的能力了。</p>
</blockquote>
<p><img src="/images/post-aop/201904240‏‎55936.png" alt=""></p>
<p>在运行时期可以按照Java虚拟机规范对class文件的组织规则生成对应的二进制字节码。当前有很多开源框架可以完成这些功能，如ASM，Javassist。</p>
<blockquote>
<p>Proxy角色在执行代理业务的时候，无非是在调用真正业务之前或者之后做一些“额外”业务。</p>
</blockquote>
<p><img src="/images/post-aop/20190424060834.png" alt=""></p>
<p>上图可以看出，代理类处理的逻辑很简单：在调用某个方法前及方法后做一些额外的业务。换一种思路就是：在触发（invoke）真实角色的方法之前或者之后做一些额外的业务。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。这种管理器就是Invocation Handler。</p>
<p>动态代理模式的结构跟上面的静态代理模式有所不同的地方，就在于多引入了一个InvocationHandler角色。</p>
<p>在静态代理中，代理Proxy中的方法，都指定了调用了特定的realSubject中的对应的方法：</p>
<p>在上面的静态代理模式下，Proxy所做的事情，无非是调用在不同的request时，调用触发realSubject对应的方法；更抽象点看，Proxy所作的事情；在Java中 方法（Method）也是作为一个对象来看待了，</p>
<blockquote>
<p>动态代理工作的基本模式就是将自己的方法功能的实现交给 InvocationHandler角色，外界对Proxy角色中的每一个方法的调用，Proxy角色都会交给InvocationHandler来处理，而InvocationHandler则调用具体对象角色的方法。如下图所示：</p>
</blockquote>
<p><img src="/images/post-aop/20190424061348.png" alt=""></p>
<p>在这种模式之中：代理Proxy 和RealSubject 应该实现相同的功能，这一点相当重要。（这里说的功能，可以理解为某个类的public方法）</p>
<p>在面向对象的编程之中，如果想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式：<br>a. 一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。<br>b. 还有比较隐晦的方式，就是通过继承。因为如果Proxy继承自RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。</p>
<p>其中JDK中提供的创建动态代理的机制，是以a这种思路设计的（基于接口），而cglib 则是以b思路设计的（基于类继承）。</p>
<blockquote>
<p>资源出自动态代理的神总结文章：<a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></p>
</blockquote>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><b>装饰者模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。</b>它是通过创建一个包装对象，也就是装饰者来包裹真实的对象。<br>装饰者模式的实现上，与静态代理极为相似，都是透过增强被代理者的功能来做到扩展对象。关键的不同点在于：代理强调的是<b>为其他对象提供一种代理以控制对这个对象的访问</b>，而装饰者仅仅强调扩展，并不强调访问控制。而动态代理比装饰者模式更加灵活，被增强的对象和增强的内容都是可以更换的，动态化的。</p>
<h1 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h1><p>AOP具体的通知包含</p>
<ul>
<li>@Before，前置通知，执行方法前执行</li>
<li>@AfterReturn，返回通知，正常返回方法后执行</li>
<li>@After，后置通知，方法最终结束后执行，相当于finaly</li>
<li>@Around，环绕通知，围绕整个方法</li>
<li>@AfterThrowing，异常通知，抛出异常后执行<br>开发者在命中连接点时，可以通过以上不同的通知，执行对应方法。这就是AOP中的Advisor。</li>
</ul>
<p>一图胜千言：<br><img src="/images/post-aop/20190425065216.png" alt=""></p>
<p>辅助记忆各种通知类型：<br><img src="/images/post-aop/20190422045144.png" alt=""></p>
<p>具体术语包括</p>
<ul>
<li><b>Aspect</b>，切面，一个关注点的模块。<br>例子中，LogAspect就是切面。</li>
<li><b>JoinPoint</b>， 连接点，程序执行中的某个点，某个位置。<br>例子中，testBean.getName()是连接点。</li>
<li><b>PointCut</b>，切点，切面匹配连接点的点，一般与切点表达式相关，就是切面如何切点。<br>例子中，@PointCut注解就是切点表达式，匹配对应的连接点</li>
<li><b>Advice</b>，通知，指在切面的某个特定的连接点上执行的动作，也叫增强行为。<br>例子中，before()与after()方法中的代码。</li>
<li><b>TargetObject</b>，目标对象，指被切入的对象，也就是被代理的对象。<br>例子中，从ctx中取出的testBean则是目标对象。</li>
<li><b>Weave</b>，织入，将Advice作用在JoinPoint的过程。</li>
</ul>
<p>一图胜千言（图片源自网络）：<br><img src="/images/post-aop/20190422031720.png" alt=""></p>
<h1 id="Spring-AOP过程"><a href="#Spring-AOP过程" class="headerlink" title="Spring AOP过程"></a>Spring AOP过程</h1><p>1、Spring加载自动代理器AnnotationAwareAspectJAutoProxyCreator，当作一个系统组件。</p>
<p>2、当一个bean加载到Spring中时，会触发自动代理器中的bean后置处理</p>
<p>3、bean后置处理，会先扫描bean中所有的Advisor</p>
<p>4、然后用这些Adviosr和其他参数构建ProxyFactory</p>
<p>5、ProxyFactory会根据配置和目标对象的类型寻找代理的方式（JDK动态代理或CGLIG代理）</p>
<p>6、然后代理出来的对象放回context中，完成Spring AOP代理配置，等待被代理类的被调用</p>
<p>7、响应被代理类被调度，设置拦截器回调（JDK Proxy透过InvocationHandler、CGLIB透过DynamicAdvisedInterceptor完成回调）。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>以AspectJ实现为例：</p>
<ul>
<li><p>Maven POM依赖配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个待代理的业务Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">( String name )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个切面Bean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pointcut</span>( <span class="string">"execution(* com.xu.test.aop.TestBean.getName())"</span> )</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 指向上面的getName()切点，透过getName()的PointCut注解指向真实被代理的方法，也就是execution里的表达式所指向的方法</span></span><br><span class="line">	<span class="meta">@Before</span>( <span class="string">"getName()"</span> )</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">( JoinPoint jp )</span> </span>&#123;</span><br><span class="line">		String clazzName = jp.getTarget().getClass().getName();</span><br><span class="line">		String methodName = jp.getSignature().getName();</span><br><span class="line">		System.out.println( <span class="string">"before "</span> + clazzName + <span class="string">"."</span> + methodName + <span class="string">" executing"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After</span>( <span class="string">"getName()"</span> )</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">( JoinPoint jp )</span> </span>&#123;</span><br><span class="line">		String clazzName = jp.getTarget().getClass().getName();</span><br><span class="line">		String methodName = jp.getSignature().getName();</span><br><span class="line">		System.out.println( <span class="string">"after "</span> + clazzName + <span class="string">"."</span> + methodName + <span class="string">" executing"</span> );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// org.springframework.aop.aspectj.AspectJAfterThrowingAdvice</span></span><br><span class="line"><span class="comment">//	@AfterThrowing( throwing = "ex", pointcut = "getName()" )</span></span><br><span class="line"><span class="comment">//	public void afterThrowing( JoinPoint jp, Throwable ex ) &#123;</span></span><br><span class="line"><span class="comment">//		String clazzName = jp.getTarget().getClass().getName();</span></span><br><span class="line"><span class="comment">//		String methodName = jp.getSignature().getName();</span></span><br><span class="line"><span class="comment">//		System.out.println( "throw exception when " + clazzName + "." + methodName + " executing" );</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// org.springframework.aop.aspectj.AspectJAroundAdvice</span></span><br><span class="line"><span class="comment">//	@Around( value = "getName()" ) </span></span><br><span class="line"><span class="comment">//	// 除了around通知，其余类型的通知都不能用ProceedingJoinPoint，只能用普通的JoinPoint</span></span><br><span class="line"><span class="comment">//	public void around( ProceedingJoinPoint pjp  ) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//		String clazzName = pjp.getTarget().getClass().getName();</span></span><br><span class="line"><span class="comment">//		String methodName = pjp.getSignature().getName();</span></span><br><span class="line"><span class="comment">//		System.out.println( "before " + clazzName + "." + methodName + " executing" );</span></span><br><span class="line"><span class="comment">//		Object result = pjp.proceed();</span></span><br><span class="line"><span class="comment">//		System.out.println( "after " + clazzName + "." + methodName + " executing, result = " + result );</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置业务Bean与切面Bean（aop-test.xml）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">	   <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">class</span>=<span class="string">"com.xu.test.aop.TestBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.xu.test.aop.LogAspect"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代理类执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop-test.xml"</span>);</span><br><span class="line">		</span><br><span class="line">		TestBean tb = ctx.getBean( <span class="string">"testBean"</span>, TestBean.class );</span><br><span class="line">		</span><br><span class="line">		tb.setName( <span class="string">"xxx"</span> );</span><br><span class="line"></span><br><span class="line">		String name = tb.getName();</span><br><span class="line">		</span><br><span class="line">		System.out.println( name );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果</p>
<blockquote>
<p>before com.xu.test.aop.TestBean.getName executing<br>after com.xu.test.aop.TestBean.getName executing<br>xxx</p>
</blockquote>
</li>
</ul>
<p>上面的例子之所以能完成AOP的代理，只因为Spring的xml配置里面加了这一句</p>
<blockquote>
<p>&lt; aop : aspectj-autoproxy / &gt;</p>
</blockquote>
<p>加上了这一个配置，使得整个Spring项目拥有了AOP的功能。全局搜索下aspectj-autoproxy这个字段，可以发现，是这个类AspectJAutoProxyBeanDefinitionParser解析了这个元素。</p>
<p>其中的parse方法调用的是AopNamespaceUtils类中的registerAspectJAnnotationAutoProxyCreatorIfNecessary。这个方法作用是初始化一个AOP专用的Bean，并且注册到Spring容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">		AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">		extendBeanDefinition(element, parserContext);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">			parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">	useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">	registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析这三个操作，</p>
<p>1、第一句，注册一个AnnotationAwareAspectJAutoProxyCreator（称它为自动代理器），这个Creator是AOP的操作核心，也是扫描Bean，代理Bean的操作所在。</p>
<p>2、第二句，解析配置元素，决定代理的模式。其中有JDK动态代理，还有CGLIB代理。</p>
<p>3、第三句，作为系统组件，把Creator这个Bean，放到Spring容器中。让Spring实例化，启动这个Creator。</p>
<h2 id="自动代理器"><a href="#自动代理器" class="headerlink" title="自动代理器"></a>自动代理器</h2><p>自动代理器 AnnotationAwareAspectJAutoProxyCreator 继承自 AbstractAutoProxyCreator，AbstractAutoProxyCreator里边实现了BeanPostProceesor接口的postProcessAfterInitialization方法，这个方法是在一个Bean被加载并注册到Spring IOC容器后，由BeanFactory回调执行的，也就是说，<b>切面是在目标对象被实例化的时候织入目标对象的，更准确的说，切面是在目标对象的bean在完成初始实例化之后，由bean工厂回调bean的后置处理器将切面织入到目标对象中的。</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">			<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里边的wrapIfNecessary方法会生成一个新的代理对象，返回context（容器上下文）中加载。</p>
<p>AOP最核心的逻辑就在这个 wrapIfNecessary方法里边，里边主要是获取通知(advice/advisor)放到一个名为specificInterceptors的数组里，然后作为参数去调用createProxy方法，创建对应的代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">	Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">		<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">		Object proxy = createProxy(</span><br><span class="line">				bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">		<span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">		<span class="keyword">return</span> proxy;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很显然，这里边有两个核心方法，就是getAdvicesAndAdvisorsForBean（获取通知），还有createProxy（创建代理）</p>
<h2 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h2><p>getAdvicesAndAdvisorsForBean，顾名思义，就是获取被代理的Bean所关联的advice及advisor，自然地，这里有个疑问，advice与advisor是什么关系，为什么获取通知不是只需要获取advice即可？Spring使用org.springframework.aop.Advisor接口表示切面的概念，当完成对目标对象方法的增强行为操作(也就是通知，Advice)和切入点（Point）的设计开发之后，需要一个对象将目标对象、增强行为和切入点三者结合起来，而Advisor(通知器)就是一个实现这个功能的对象，即通过Advisor通知器，可以定义哪些目标对象的哪些方法在什么地方使用这些增强的行为。简单来讲，<b>Advisor=Advice+Point。</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advisor</span> </span>&#123;    </span><br><span class="line">    <span class="comment">//获取切面的通知Advice    </span></span><br><span class="line">    <span class="function">Advice <span class="title">getAdvice</span><span class="params">()</span></span>;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//判断这个通知是否和某个特定的实例对象相关    </span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPerInstance</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，debug进去AbstractAdvisorAutoProxyCreator对getAdvicesAndAdvisorsForBean的实现代码，可以看到，其实这里确实只是获取Advisor通知器而已，如上文说的，每个Advisor对象持有一个Advice通知，一步步debug，进入到AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors()，找到BeanFactoryAspectJAdvisorsBuilder中的buildAspectJAdvisors方法，这个方法里边就是寻找AspectBean，然后返回AspectBean中的所有Advisor的过程实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for AspectJ-annotated aspect beans in the current bean factory,</span></span><br><span class="line"><span class="comment"> * and return to a list of Spring AOP Advisors representing them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Creates a Spring Advisor for each AspectJ advice method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of &#123;<span class="doctag">@link</span> org.springframework.aop.Advisor&#125; beans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isEligibleBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; aspectNames = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">		<span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">			List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">			aspectNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">			String[] beanNames =</span><br><span class="line">					BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// We must be careful not to instantiate beans eagerly as in this</span></span><br><span class="line">				<span class="comment">// case they would be cached by the Spring container but would not</span></span><br><span class="line">				<span class="comment">// have been weaved</span></span><br><span class="line">				Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">				<span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">					aspectNames.add(beanName);</span><br><span class="line">					AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">					<span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">						MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">								<span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">						List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">							<span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">						&#125;</span><br><span class="line">						advisors.addAll(classAdvisors);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// Per target or per this.</span></span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">									<span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">								<span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">						<span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">						advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">			<span class="keyword">return</span> advisors;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125;</span><br><span class="line">	List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">		List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">		<span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">			advisors.addAll(cachedAdvisors);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">			advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>譬如，例子中的LogAspect就是AspectBean，它定义了Before与After两个通知（或者说增强行为），那么最终便返回LogAspect中的Before与After对应的Advisor通知器。</p>
<h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Create an AOP proxy for the given bean.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanClass the class of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> specificInterceptors the set of interceptors that is</span></span><br><span class="line"><span class="comment">    * specific to this bean (may be empty, but not null)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> targetSource the TargetSource for the proxy,</span></span><br><span class="line"><span class="comment">    * already pre-configured to access the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the AOP proxy for the bean</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #buildAdvisors</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">           AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">       &#125;</span><br><span class="line">　　　　　</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *这里是与后面的代理拦截器链调用的逻辑有关</span></span><br><span class="line"><span class="comment">	 * ProxyFactory本质上就是一个ProxyConfig，它透过多层继承，最终继承到了ProxyConfig</span></span><br><span class="line"><span class="comment">	 * 继承链路是：ProxyFactory -&gt; ProxyCreatorSupport -&gt; AdvisedSupport -&gt; ProxyConfig</span></span><br><span class="line"><span class="comment">	 * 所以这里new一个ProxyFactory其实就是创建一个ProxyConfig对象，</span></span><br><span class="line"><span class="comment">	 * 这个ProxyConfig对象将会存储与目标对象相匹配的advisor，这就是所谓的织入。</span></span><br><span class="line"><span class="comment">	 * 等到调用目标对象的时候再将advisor取出来包装（转换）成拦截器。最后组成拦截器链。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">       ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">       proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">                </span><br><span class="line">　　　　　　　　　　proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">/** 这里是指定拦截器（specificInterceptors）包装成advisor。</span></span><br><span class="line"><span class="comment">	 * 这个specificInterceptors是作为这个方法的参数传进来的。</span></span><br><span class="line"><span class="comment">	 * 也就是说在这之前就已经将与目标对象相匹配的拦截器构建好了。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">       Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">       <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">           <span class="comment">//这里就是织入，将与目标对象相匹配的advisor存储到ProxyConfig对象中。</span></span><br><span class="line">           proxyFactory.addAdvisor(advisor);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       proxyFactory.setTargetSource(targetSource);</span><br><span class="line">       customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">       proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">       <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">           proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>把Advisor丢到proxyFactory（ProxyConfig）之后，最后要从proxyFactory里获取一个代理对象。也就是，ProxyFactory的getProxy方法，一路debug进去方法，最终可以在DefaultAopProxyFactory中createAopProxy的实现中，看到代理对象是怎么被生成的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">						<span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProxyFactory会根据配置与目标对象的类型，选择用JDK动态代理，还是CGLIB的代理，代理后的对象会放回context中，然后等到程序执行时，会直接调用这个代理类。<br>留意到这里的JDK动态代理 or CGLIB动态代理的选择逻辑，体现到了<b>目标为接口时使用JDK动态代理，目标为类时使用CGLIB动态代理</b>的意思。<br><br><br>至此，整个代理的织入、连接过程就已完成。接下来的问题是，调用时怎么给目标类（被代理类）作访问拦截的。</p>
<h1 id="AOP代理拦截"><a href="#AOP代理拦截" class="headerlink" title="AOP代理拦截"></a>AOP代理拦截</h1><p>上面的代码分析中，已经知道，在Spring AOP通过JDK的Proxy方式或者CGLIB方式生成代理对象的时候，相关的拦截器已经生成并配置到代理对象中去了。<br>那么，拦截器的回调，是怎么设置的呢？<br>有两种方式：</p>
<ul>
<li>JDK的Proxy方式生成代理对象：JdkDynamicAopProxy会通过连接点（ReflectiveMethodInvocation）来调用拦截器链中的拦截器（也就是调用通知方法）</li>
<li>CGLIB方式生成代理对象：根据CGLIB使用要求，通过DynamicAdvisedInterceptor来完成回调。</li>
</ul>
<p>在《Spring技术内幕（第2版）》中有截取到两种方式的拦截器在Spring代码中的实现。</p>
<h2 id="JdkDynamicAopProxy的invoke拦截"><a href="#JdkDynamicAopProxy的invoke拦截" class="headerlink" title="JdkDynamicAopProxy的invoke拦截"></a>JdkDynamicAopProxy的invoke拦截</h2><p>具体实现看org.springframework.aop.framework.JdkDynamicAopProxy.invoke(Object, Method, Object[])源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	MethodInvocation invocation;</span><br><span class="line">	Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">	Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">	Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">			<span class="keyword">return</span> hashCode();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">			<span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">				method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">			<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">			oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">			setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到目标对象的地方</span></span><br><span class="line">		target = targetSource.getTarget();</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">			targetClass = target.getClass();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里获取到定义好的拦截器链</span></span><br><span class="line">		<span class="comment">// 这里的this.advised是个AdvisedSupport类型（继承ProxyConfig），就是一个ProxyConfig</span></span><br><span class="line">		<span class="comment">// 进去getInterceptorsAndDynamicInterceptionAdvice方法，便会发现上文提到的Advisor转换成拦截器的过程</span></span><br><span class="line">		List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有设定拦截器（拦截器链为空），那么就直接调用target的对应方法</span></span><br><span class="line">		<span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">			Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">			retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果有拦截器的设定，那么需要调用拦截器之后才调用目标对象的相应方法</span></span><br><span class="line">			<span class="comment">// 通过构造一个ReflectiveMethodInvocation对象来实现</span></span><br><span class="line">			invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">			<span class="comment">// 沿着拦截器链继续前进（执行）</span></span><br><span class="line">			retVal = invocation.proceed();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">		<span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">			retVal = proxy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">					<span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">			targetSource.releaseTarget(target);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">			AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine a list of &#123;<span class="doctag">@link</span> org.aopalliance.intercept.MethodInterceptor&#125; objects</span></span><br><span class="line"><span class="comment"> * for the given method, based on this configuration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the proxied method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass the target class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里作了缓存，把已有的interceptor链存起来，除了首次要生成，后续获取都是走的缓存，节省时间</span></span><br><span class="line">	<span class="comment">// 这个interceptor链的生成是由advisorChainFactory完成的，在这里使用的是DefaultAdvisorChainFactory</span></span><br><span class="line">	MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">	List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">	<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">		cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">				<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">		<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorChainFactory</span> <span class="keyword">implements</span> <span class="title">AdvisorChainFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Advised config, Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">		<span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">		<span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">				<span class="comment">// Add it conditionally.</span></span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					<span class="comment">// Advisor入参，获取到已经注册好的方法拦截器</span></span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					<span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> interceptorList;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cglib2AopProxy的intercept拦截"><a href="#Cglib2AopProxy的intercept拦截" class="headerlink" title="Cglib2AopProxy的intercept拦截"></a>Cglib2AopProxy的intercept拦截</h2><p>具体实现看org.springframework.aop.framework.Cglib2AopProxy.DynamicAdvisedInterceptor.intercept(Object, Method, Object[], MethodProxy)源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General purpose AOP callback. Used when the target is dynamic or when the</span></span><br><span class="line"><span class="comment"> * proxy is not frozen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.advised = advised;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">		Class targetClass = <span class="keyword">null</span>;</span><br><span class="line">		Object target = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			target = getTarget();</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 从advised(AdvisedSupport类型，继承自ProxyConfig)中取得配置好的通知</span></span><br><span class="line">			List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有配置的AOP通知，那么就直接调用target的对应方法</span></span><br><span class="line">			<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">				retVal = methodProxy.invoke(target, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 通过CglibMethodInvocation来启动advice通知</span></span><br><span class="line">				retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">			&#125;</span><br><span class="line">			retVal = massageReturnTypeIfNecessary(proxy, target, method, retVal);</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">				releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="AOP拦截器的调用"><a href="#AOP拦截器的调用" class="headerlink" title="AOP拦截器的调用"></a>AOP拦截器的调用</h2><p>两种方式对拦截器的调用都是在ReflectiveMethodInvocation中通过proceed方法实现。在proceed方法中逐个实现拦截器的拦截方法。每个拦截器在执行之前，需要对代理方法完成一个匹配判断（即Pointcut切点中需要进行matches匹配过程）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="comment">// 从索引为-1的拦截器开始调用，并按序递增</span></span><br><span class="line">	<span class="comment">// 如果拦截器链中的拦截器迭代调用完毕，这里开始调用target的函数，这个函数时通过反射机制完成的</span></span><br><span class="line">	<span class="comment">// 这个函数具体实现在AopUtils.invokeJoinpointUsingReflection方法中</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		<span class="comment">// 这里对拦截器进行动态匹配的判断</span></span><br><span class="line">		<span class="comment">//这里是触发进行匹配的地方，如果和定义好的PointCut匹配，那么这个advice将会得到执行</span></span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，整个AOP实现的来龙去脉，便走完了个大致流程。</p>
<h1 id="JVM级别的AOP"><a href="#JVM级别的AOP" class="headerlink" title="JVM级别的AOP"></a>JVM级别的AOP</h1><p><a href="https://www.jianshu.com/p/b72f66da679f" target="_blank" rel="noopener">基于Java Instrument的Agent实现</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="noopener">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a></li>
<li><a href="https://juejin.im/post/5c01533de51d451b80257752" target="_blank" rel="noopener">一文读懂 AOP | 你想要的最全面 AOP 方法探讨</a></li>
<li><a href="https://zackku.com/spring-aop/" target="_blank" rel="noopener">从源码入手，一文带你读懂Spring AOP面向切面编程</a></li>
<li><a href="https://link.jianshu.com/?t=https://book.douban.com/subject/10470970/" target="_blank" rel="noopener">Spring设计内幕（第2版）》计文柯</a></li>
</ul>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/04/20/LRUCache/">
        <span class="nav-arrow">← </span>
        
          LRU Cache
        
      </a>
    
    
      <a class="nav-right" href="/2019/05/07/MySQL-Transaction-MVCC/">
        
          MySQL-Transaction-MVCC
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <!--<div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>-->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#What’s-AOP"><span class="toc-nav-text">What’s AOP</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#AOP用处"><span class="toc-nav-text">AOP用处</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#参数校验和判空"><span class="toc-nav-text">参数校验和判空</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#权限控制"><span class="toc-nav-text">权限控制</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#无痕埋点"><span class="toc-nav-text">无痕埋点</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#安全控制"><span class="toc-nav-text">安全控制</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#日志记录"><span class="toc-nav-text">日志记录</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#性能统计"><span class="toc-nav-text">性能统计</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#事务处理"><span class="toc-nav-text">事务处理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#异常处理"><span class="toc-nav-text">异常处理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#缓存"><span class="toc-nav-text">缓存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#设计模式"><span class="toc-nav-text">设计模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#代理模式"><span class="toc-nav-text">代理模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#静态代理"><span class="toc-nav-text">静态代理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#动态代理"><span class="toc-nav-text">动态代理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#装饰者模式"><span class="toc-nav-text">装饰者模式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#AOP术语"><span class="toc-nav-text">AOP术语</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Spring-AOP过程"><span class="toc-nav-text">Spring AOP过程</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#源码分析"><span class="toc-nav-text">源码分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#自动代理器"><span class="toc-nav-text">自动代理器</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#获取通知"><span class="toc-nav-text">获取通知</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#创建代理"><span class="toc-nav-text">创建代理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#AOP代理拦截"><span class="toc-nav-text">AOP代理拦截</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JdkDynamicAopProxy的invoke拦截"><span class="toc-nav-text">JdkDynamicAopProxy的invoke拦截</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Cglib2AopProxy的intercept拦截"><span class="toc-nav-text">Cglib2AopProxy的intercept拦截</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#AOP拦截器的调用"><span class="toc-nav-text">AOP拦截器的调用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#JVM级别的AOP"><span class="toc-nav-text">JVM级别的AOP</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Reference"><span class="toc-nav-text">Reference</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/04/22/AOP/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fgu123";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "AOP",
        owner: "fgu123",
        repo: "fgu123.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2019/04/22/AOP/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>