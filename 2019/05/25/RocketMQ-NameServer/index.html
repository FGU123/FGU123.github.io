<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="ppxu&#39;s blog">
  <meta name="keyword" content="java, blog, article">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      RocketMQ NameServer | PPXu
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>

  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 7.1.1"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PPXu</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/search" class="item-link">Search</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/search" class="menu-link">Search</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RocketMQ NameServer</h2>
  <p class="post-date">2019-05-25</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="路由中心Namesrv设计"><a href="#路由中心Namesrv设计" class="headerlink" title="路由中心Namesrv设计"></a>路由中心Namesrv设计</h1><p>Namesrv就是RocketMQ的路由中心，也就是路由元信息的管理中心。主要作用是为消息生产者（Producer）、消费者（Consumer）提供关于主题（Topic）的路由信息，那么，Namesrv需要存储路由的基础信息，还要能管理Broker节点，包括路由注册、路由删除等功能。Namesrv被设计为RocketMQ统一的路由中心，这也就是为何，Producer与Consumer在启动时，统一需要在Namesrv上面注册，而非Broker。</p>
<h2 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h2><p>NameServer路由实现类：org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager。</p>
<p><img src="/images/post-RocketMQ-NameServer/20190525085014.png"></p>
<p>主要属性<br>•	topicQueueTable: Topic 下的消息队列路由信息，消息发送时根据路由表进行负载均衡。<br>•	brokerAddrTable : Broker 基础信息， 包含brokerName 、所属集群名称、主备Broker地址。<br>•	clusterAddrTable: Broker 集群信息，存储集群中所有Broker 名称。<br>•	brokerLiveTable: Broker 状态信息。NameServer 每次收到心跳包时会替换该信息，这是实现Broker服务更新的关键。<br>•	filterServerTable : Broker 上的FilterServer 列表，用于类模式消息过滤，这涉及到消息过滤的功能。</p>
<h1 id="Namesrv实现类一览"><a href="#Namesrv实现类一览" class="headerlink" title="Namesrv实现类一览"></a>Namesrv实现类一览</h1><p><img src="/images/post-RocketMQ-NameServer/20190525085521.png"><br>包结构不复杂，类数据量也不多，关键的几个类是：<br>•	NamesrvStartup：启动类<br>•	NamesrvController：核心控制器<br>•	RouteInfoManager：路由信息表</p>
<h1 id="Namesrv启动"><a href="#Namesrv启动" class="headerlink" title="Namesrv启动"></a>Namesrv启动</h1><p>从Namesrv的启动类NamesrvStartup撸起（文中提到代码均基于RocketMQ 4.5.1版本）：<br><b>org.apache.rocketmq.namesrv.NamesrvStartup.main0(String[]) </b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">main0</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> createNamesrvController(args);</span><br><span class="line">		start(controller);</span><br><span class="line">		<span class="type">String</span> <span class="variable">tip</span> <span class="operator">=</span> <span class="string">&quot;The Name Server boot success. serializeType=&quot;</span> + RemotingCommand.getSerializeTypeConfigInThisServer();</span><br><span class="line">		log.info(tip);</span><br><span class="line">		System.out.printf(<span class="string">&quot;%s%n&quot;</span>, tip);</span><br><span class="line">		<span class="keyword">return</span> controller;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		System.exit(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个NameServer的服务启动流程代码都在这个main0(String[] args)方法里了，咋一看，还是比较简单的，大体流程分三步：</p>
<ol>
<li>创建NamesrvController对象，</li>
<li>启动NamesrvController，</li>
<li>记log并返回NamesrvController对象。步骤三就很简单了，一目了然，那么接下来分析步骤一及步骤二。</li>
</ol>
<h2 id="创建NamesrvController对象"><a href="#创建NamesrvController对象" class="headerlink" title="创建NamesrvController对象"></a>创建NamesrvController对象</h2><p>完整代码：<br><b>org.apache.rocketmq.namesrv.NamesrvStartup.createNamesrvController(String[])</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException &#123;</span><br><span class="line">       System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">       <span class="comment">//PackageConflictDetect.detectFastjson();</span></span><br><span class="line"></span><br><span class="line">       <span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> <span class="title class_">Options</span>());</span><br><span class="line">       commandLine = ServerUtil.parseCmdLine(<span class="string">&quot;mqnamesrv&quot;</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> <span class="title class_">PosixParser</span>());</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">null</span> == commandLine) &#123;</span><br><span class="line">           System.exit(-<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">       nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line">       <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">           <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">               properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">               properties.load(in);</span><br><span class="line">               MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">               MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">               namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">               System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">               in.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;p&#x27;</span>)) &#123;</span><br><span class="line">           <span class="type">InternalLogger</span> <span class="variable">console</span> <span class="operator">=</span> InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">           MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">           MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">           System.exit(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">null</span> == namesrvConfig.getRocketmqHome()) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;Please set the %s variable in your environment to match the location of the RocketMQ installation%n&quot;</span>, MixAll.ROCKETMQ_HOME_ENV);</span><br><span class="line">           System.exit(-<span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">LoggerContext</span> <span class="variable">lc</span> <span class="operator">=</span> (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">       <span class="type">JoranConfigurator</span> <span class="variable">configurator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoranConfigurator</span>();</span><br><span class="line">       configurator.setContext(lc);</span><br><span class="line">       lc.reset();</span><br><span class="line">       configurator.doConfigure(namesrvConfig.getRocketmqHome() + <span class="string">&quot;/conf/logback_namesrv.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">       log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">       MixAll.printObjectProperties(log, namesrvConfig);</span><br><span class="line">       MixAll.printObjectProperties(log, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">       controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> controller;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里方法的代码就比较多了，我们拆成几段来撸就比较好分析了：<br><b>org.apache.rocketmq.namesrv.NamesrvStartup.createNamesrvController(String[])</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> <span class="title class_">Options</span>());</span><br><span class="line">commandLine = ServerUtil.parseCmdLine(<span class="string">&quot;mqnamesrv&quot;</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> <span class="title class_">PosixParser</span>());</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == commandLine) &#123;</span><br><span class="line">	System.exit(-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段是使用了Apache Commons CLI命令行（Command Line Interface）解析工具，它主要是根据运行时传递进来的参数生成commandLine命令行对象，用于解析运行时类似于 -c 指定文件路径，然后填充到 namesrvConfig 和 nettyServerConfig 对象中。<br>那么，之后的两个小步骤，就是 这两个配置的填充过程了：</p>
<p><b>org.apache.rocketmq.namesrv.NamesrvStartup.createNamesrvController(String[]) </b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">NamesrvConfig</span> <span class="variable">namesrvConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvConfig</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">NettyServerConfig</span> <span class="variable">nettyServerConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerConfig</span>();</span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">&#x27;c&#x27;</span>)) &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> commandLine.getOptionValue(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">		properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		properties.load(in);</span><br><span class="line">		MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">		MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">		namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">&quot;load config properties file OK, %s%n&quot;</span>, file);</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段是createNamesrvController(String[] args)方法最为核心的代码，从代码可以看到，先创建NamesrvConfig和NettyServerConfig对象，接着利用commandLine命令行工具读取-c指定的配置文件路径，然后将其读取到流中，生成properties对象，最后将namesrvConfig和nettyServerConfig对象进行初始化。</p>
<p>这里省略一些没有那么重要的细节代码，譬如支持配置查看模式（命令行添加 -p，则把当前的环境配置输出来）、日志上下文配置（包括日志文件路径设定，Logger获取），这里不细看，接着往下看：</p>
<p><b>org.apache.rocketmq.namesrv.NamesrvStartup.createNamesrvController(String[])</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">NamesrvController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamesrvController</span>(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controller;</span><br></pre></td></tr></table></figure>

<p>到这里就是水到渠成，利用namesrvConfig和nettyServerConfig对象创建NamesrvController对象，然后在注册一遍properties，防止丢失。</p>
<h2 id="启动NamesrvController"><a href="#启动NamesrvController" class="headerlink" title="启动NamesrvController"></a>启动NamesrvController</h2><p>回到 org.apache.rocketmq.namesrv.NamesrvStartup.main0(String[] args) 方法，看进去 start(NamesrvController) 方法<br><b>org.apache.rocketmq.namesrv.NamesrvStartup.start(NamesrvController) </b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title function_">start</span><span class="params">(<span class="keyword">final</span> NamesrvController controller)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">null</span> == controller) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;NamesrvController is null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">initResult</span> <span class="operator">=</span> controller.initialize();</span><br><span class="line">       <span class="keyword">if</span> (!initResult) &#123;</span><br><span class="line">           controller.shutdown();</span><br><span class="line">           System.exit(-<span class="number">3</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">ShutdownHookThread</span>(log, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Void&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               controller.shutdown();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;));</span><br><span class="line"></span><br><span class="line">       controller.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> controller;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是对核心控制器进行初始化操作，其次是注册一个钩子函数，用于JVM进程关闭时，优雅地释放netty服务、线程池等资源，最后对核心控制器进行启动操作，接下来我们继续撸org.apache.rocketmq.namesrv.NamesrvController.initialize() 详细实现：<br><b>org.apache.rocketmq.namesrv.NamesrvController.initialize()</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加载kv配置</span></span><br><span class="line">       <span class="built_in">this</span>.kvConfigManager.load();</span><br><span class="line">       <span class="comment">// 加载netty网络服务对象，并注册</span></span><br><span class="line">       <span class="built_in">this</span>.remotingServer = <span class="keyword">new</span> <span class="title class_">NettyRemotingServer</span>(<span class="built_in">this</span>.nettyServerConfig, <span class="built_in">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">this</span>.remotingExecutor =</span><br><span class="line">           Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> <span class="title class_">ThreadFactoryImpl</span>(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">this</span>.registerProcessor();</span><br><span class="line">       <span class="comment">// 创建定时任务--每隔10秒扫描一次Broker，并定时删除不活跃的Broker</span></span><br><span class="line">       <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               NamesrvController.<span class="built_in">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">// 创建定时任务--每隔10分钟打印一遍kv配置</span></span><br><span class="line">       <span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               NamesrvController.<span class="built_in">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 之后是注册一个监听器，去监听Ssl上下文环境的变更，主要透过Tls证书文件监听进行</span></span><br><span class="line">       <span class="comment">// 。。。</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>至此，就是最后一步了，就是创建Netty服务来进行通信，关于Netty的实现细节较多，这里不深入，要想了解可以看一下Netty相关文章。</p>
<h2 id="路由启动时序图"><a href="#路由启动时序图" class="headerlink" title="路由启动时序图"></a>路由启动时序图</h2><p><img src="/images/post-RocketMQ-NameServer/20190525090837.png"></p>
<h1 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h1><p>路由注册即是Broker向Nameserver注册的过程，它们是通过Broker的心跳功能实现的，既然Nameserver是用来存储Broker的注册信息，那么我们就先来看看Nameserver到底存储了哪些信息，就是上文那张结构图，我们知道RouteInfoManager为路由信息表。</p>
<p>RocketMQ是基于订阅发布机制的，一个Topic拥有多个消息队列，如果不指定队列的数量，一个Broker默认会为每个Topic创建4个读队列和4个写队列，多个Broker组成集群，Broker会通过发送心跳包将自己的信息注册到路由中心，路由中心brokerLiveTable存储Broker的状态，它会根据Broker的心跳包更新Broker状态信息。</p>
<h2 id="Broker发送心跳包"><a href="#Broker发送心跳包" class="headerlink" title="Broker发送心跳包"></a>Broker发送心跳包</h2><p><b>org.apache.rocketmq.broker.BrokerController.start()</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 初次启动，这里会强制执行发送心跳包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BrokerController.<span class="built_in">this</span>.registerBrokerAll(<span class="literal">true</span>, <span class="literal">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;registerBrokerAll Exception&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>Broker在核心控制器启动时，会强制发送一次心跳包，接着创建一个定时任务，定时向路由中心发送心跳包。由 brokerConfig.getRegisterNameServerPeriod() 可以看到这个定时时间支持可配置，但是调了两个Math类的限制大小函数，把时间限定在[10，60]这个区间，默认是30秒。<br>接下来，进去org.apache.rocketmq.broker.BrokerController.registerBrokerAll(boolean, boolean, boolean)方法看下：<br><b>org.apache.rocketmq.broker.BrokerController.registerBrokerAll(boolean, boolean, boolean)</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerBrokerAll</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> checkOrderConfig, <span class="type">boolean</span> oneway, <span class="type">boolean</span> forceRegister)</span> &#123;</span><br><span class="line">       <span class="type">TopicConfigSerializeWrapper</span> <span class="variable">topicConfigWrapper</span> <span class="operator">=</span> <span class="built_in">this</span>.getTopicConfigManager().buildTopicConfigSerializeWrapper(); <span class="comment">// 创建一个topic包装类</span></span><br><span class="line">	<span class="comment">//这里的设计是，如果该broker没有读写权限，那么会新建一个临时的topicConfigTable，再set进包装类</span></span><br><span class="line">       <span class="keyword">if</span> (!PermName.isWriteable(<span class="built_in">this</span>.getBrokerConfig().getBrokerPermission())</span><br><span class="line">           || !PermName.isReadable(<span class="built_in">this</span>.getBrokerConfig().getBrokerPermission())) &#123;  </span><br><span class="line">           ConcurrentHashMap&lt;String, TopicConfig&gt; topicConfigTable = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, TopicConfig&gt;();</span><br><span class="line">           <span class="keyword">for</span> (TopicConfig topicConfig : topicConfigWrapper.getTopicConfigTable().values()) &#123;</span><br><span class="line">               <span class="type">TopicConfig</span> <span class="variable">tmp</span> <span class="operator">=</span></span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">TopicConfig</span>(topicConfig.getTopicName(), topicConfig.getReadQueueNums(), topicConfig.getWriteQueueNums(),</span><br><span class="line">                       <span class="built_in">this</span>.brokerConfig.getBrokerPermission());</span><br><span class="line">               topicConfigTable.put(topicConfig.getTopicName(), tmp);</span><br><span class="line">           &#125;</span><br><span class="line">           topicConfigWrapper.setTopicConfigTable(topicConfigTable);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断该Broker是否需要发送心跳包</span></span><br><span class="line">       <span class="keyword">if</span> (forceRegister || needRegister(<span class="built_in">this</span>.brokerConfig.getBrokerClusterName(),</span><br><span class="line">           <span class="built_in">this</span>.getBrokerAddr(),</span><br><span class="line">           <span class="built_in">this</span>.brokerConfig.getBrokerName(),</span><br><span class="line">           <span class="built_in">this</span>.brokerConfig.getBrokerId(),</span><br><span class="line">           <span class="built_in">this</span>.brokerConfig.getRegisterBrokerTimeoutMills())) &#123;</span><br><span class="line">           doRegisterBrokerAll(checkOrderConfig, oneway, topicConfigWrapper); <span class="comment">// 执行发送心跳包</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法是Broker执行发送心跳包的核心控制方法，它主要做了topic的包装类封装操作，判断Broker此时是否需要执行发送心跳包，但<b>查看org.apache.rocketmq.common.BrokerConfig#forceRegister字段的值，发现写死为true，也就是该判断永远为true，即默认配置下是每次都需要发送心跳包。</b><br>进去看一下这个控制是否发心跳包的方法org.apache.rocketmq.broker.BrokerController.needRegister(String, String, String, long, int)<br><b>org.apache.rocketmq.broker.BrokerController.needRegister(String, String, String, long, int)</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needRegister</span><span class="params">(<span class="keyword">final</span> String clusterName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerAddr,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> <span class="type">long</span> brokerId,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> <span class="type">int</span> timeoutMills)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">TopicConfigSerializeWrapper</span> <span class="variable">topicConfigWrapper</span> <span class="operator">=</span> <span class="built_in">this</span>.getTopicConfigManager().buildTopicConfigSerializeWrapper();</span><br><span class="line">       List&lt;Boolean&gt; changeList = brokerOuterAPI.needRegister(clusterName, brokerAddr, brokerName, brokerId, topicConfigWrapper, timeoutMills);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">needRegister</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (Boolean changed : changeList) &#123;</span><br><span class="line">           <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">               needRegister = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> needRegister;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>进去里边发现，是否需要发送心跳包的逻辑还得结合 org.apache.rocketmq.broker.out.BrokerOuterAPI.needRegister(String, String, String, long, TopicConfigSerializeWrapper, int) 方法来判断。<br><b>org.apache.rocketmq.broker.out.BrokerOuterAPI.needRegister(String, String, String, long, TopicConfigSerializeWrapper, int)</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">needRegister</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String clusterName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerAddr,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> <span class="type">long</span> brokerId,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> <span class="type">int</span> timeoutMills)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> List&lt;Boolean&gt; changedList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">       List&lt;String&gt; nameServerAddressList = <span class="built_in">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line">       <span class="keyword">if</span> (nameServerAddressList != <span class="literal">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nameServerAddressList.size());</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">               brokerOuterExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="type">QueryDataVersionRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryDataVersionRequestHeader</span>();</span><br><span class="line">                           requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">                           requestHeader.setBrokerId(brokerId);</span><br><span class="line">                           requestHeader.setBrokerName(brokerName);</span><br><span class="line">                           requestHeader.setClusterName(clusterName);</span><br><span class="line">                           <span class="type">RemotingCommand</span> <span class="variable">request</span> <span class="operator">=</span> RemotingCommand.createRequestCommand(RequestCode.QUERY_DATA_VERSION, requestHeader);</span><br><span class="line">                           request.setBody(topicConfigWrapper.getDataVersion().encode());</span><br><span class="line">                           <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span><br><span class="line">                           <span class="type">DataVersion</span> <span class="variable">nameServerDataVersion</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                           <span class="type">Boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                           <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">                               <span class="keyword">case</span> ResponseCode.SUCCESS: &#123;</span><br><span class="line">                                   <span class="type">QueryDataVersionResponseHeader</span> <span class="variable">queryDataVersionResponseHeader</span> <span class="operator">=</span></span><br><span class="line">                                       (QueryDataVersionResponseHeader) response.decodeCommandCustomHeader(QueryDataVersionResponseHeader.class);</span><br><span class="line">                                   changed = queryDataVersionResponseHeader.getChanged();</span><br><span class="line">                                   <span class="type">byte</span>[] body = response.getBody();</span><br><span class="line">                                   <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">                                       nameServerDataVersion = DataVersion.decode(body, DataVersion.class);</span><br><span class="line">                                       <span class="keyword">if</span> (!topicConfigWrapper.getDataVersion().equals(nameServerDataVersion)) &#123; <span class="comment">//判断是否一致的DataVersion</span></span><br><span class="line">                                           changed = <span class="literal">true</span>;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                   <span class="keyword">if</span> (changed == <span class="literal">null</span> || changed) &#123;</span><br><span class="line">                                       changedList.add(Boolean.TRUE);</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="keyword">default</span>:</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           log.warn(<span class="string">&quot;Query data version from name server &#123;&#125; OK,changed &#123;&#125;, broker &#123;&#125;,name server &#123;&#125;&quot;</span>, namesrvAddr, changed, topicConfigWrapper.getDataVersion(), nameServerDataVersion == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : nameServerDataVersion);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                           changedList.add(Boolean.TRUE);</span><br><span class="line">                           log.error(<span class="string">&quot;Query data version from name server &#123;&#125;  Exception, &#123;&#125;&quot;</span>, namesrvAddr, e);</span><br><span class="line">                       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           countDownLatch.countDown();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               log.error(<span class="string">&quot;query dataversion from nameserver countDownLatch await Exception&quot;</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> changedList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>捋一捋这个方法的逻辑，发现，关键是这个判断 !topicConfigWrapper.getDataVersion().equals(nameServerDataVersion)，就是说，该Broker本地的topic配置的DataVersion与远程调用Namesrv获取回来的DataVersion是否一致，如果不是，则要发送心跳包。</p>
<p>我们再定位到 needRegister 远程调用到路由中心Namesrv的方法：</p>
<p><b>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager.isBrokerTopicConfigChanged(String, DataVersion)，</b><br><b>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager.queryBrokerTopicConfig(String) </b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBrokerTopicConfigChanged</span><span class="params">(<span class="keyword">final</span> String brokerAddr, <span class="keyword">final</span> DataVersion dataVersion)</span> &#123;</span><br><span class="line">       <span class="type">DataVersion</span> <span class="variable">prev</span> <span class="operator">=</span> queryBrokerTopicConfig(brokerAddr);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span> == prev || !prev.equals(dataVersion);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> DataVersion <span class="title function_">queryBrokerTopicConfig</span><span class="params">(<span class="keyword">final</span> String brokerAddr)</span> &#123;</span><br><span class="line">       <span class="type">BrokerLiveInfo</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.get(brokerAddr);</span><br><span class="line">       <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> prev.getDataVersion();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>发现，关键还是取决于Namesrv这边记录的存活Broker列表BrokerLiveInfo中的dataVersion，如果broker本地存的dataVersion为空或者当前这个dataVersion不等于NameServ的brokerLiveTable里存储的brokerLiveInfo里边的dataVersion，就说明Broker信息版本与NameServ的对不上号，则需要更新，也就是说Broker就需要发送心跳包。</p>
<h2 id="NameSrv处理心跳包"><a href="#NameSrv处理心跳包" class="headerlink" title="NameSrv处理心跳包"></a>NameSrv处理心跳包</h2><p>Nameserver的netty服务监听收到心跳包之后，会调用到路由中心以下方法进行处理：<br><b>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager.registerBroker(String, String, String, long, String, TopicConfigSerializeWrapper, List<String>, Channel)</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RegisterBrokerResult <span class="title function_">registerBroker</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String clusterName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerAddr,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String brokerName,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> <span class="type">long</span> brokerId,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> String haServerAddr,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span><br><span class="line"><span class="params">       <span class="keyword">final</span> Channel channel)</span> &#123;</span><br><span class="line">       <span class="type">RegisterBrokerResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegisterBrokerResult</span>();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line">               <span class="comment">// 获取集群下所有的Broker，并将当前Broker加入clusterAddrTable，由于brokerNames是Set结构，并不会重复</span></span><br><span class="line">               Set&lt;String&gt; brokerNames = <span class="built_in">this</span>.clusterAddrTable.get(clusterName); </span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">null</span> == brokerNames) &#123;</span><br><span class="line">                   brokerNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">                   <span class="built_in">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">               &#125;</span><br><span class="line">               brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">               <span class="type">boolean</span> <span class="variable">registerFirst</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="type">BrokerData</span> <span class="variable">brokerData</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerAddrTable.get(brokerName); <span class="comment">// 获取Broker信息，如果是首次注册，那么新建一个BrokerData并加入brokerAddrTable</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">null</span> == brokerData) &#123;</span><br><span class="line">                   registerFirst = <span class="literal">true</span>;</span><br><span class="line">                   brokerData = <span class="keyword">new</span> <span class="title class_">BrokerData</span>(clusterName, brokerName, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, String&gt;());</span><br><span class="line">                   <span class="built_in">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">               &#125;</span><br><span class="line">               Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">               <span class="comment">//Switch slave to master: first remove &lt;1, IP:PORT&gt; in namesrv, then add &lt;0, IP:PORT&gt;</span></span><br><span class="line">               <span class="comment">//The same IP:PORT must only have one record in brokerAddrTable</span></span><br><span class="line">               Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line">               <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                   Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="literal">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">                       it.remove();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 这里判断Broker是否是已经注册过</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">oldAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">               registerFirst = registerFirst || (<span class="literal">null</span> == oldAddr);</span><br><span class="line">               <span class="comment">// 如果是Broker是Master节点吗，并且Topic信息更新或者是首次注册，那么创建更新topic队列信息</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">null</span> != topicConfigWrapper</span><br><span class="line">                   &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                       || registerFirst) &#123;</span><br><span class="line">                       ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                           topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                       <span class="keyword">if</span> (tcTable != <span class="literal">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                               <span class="built_in">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 更新BrokerLiveInfo状态信息</span></span><br><span class="line">               <span class="type">BrokerLiveInfo</span> <span class="variable">prevBrokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">BrokerLiveInfo</span>(</span><br><span class="line">                       System.currentTimeMillis(),</span><br><span class="line">                       topicConfigWrapper.getDataVersion(),</span><br><span class="line">                       channel,</span><br><span class="line">                       haServerAddr));</span><br><span class="line">               <span class="keyword">if</span> (<span class="literal">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                   log.info(<span class="string">&quot;new broker registered, &#123;&#125; HAServer: &#123;&#125;&quot;</span>, brokerAddr, haServerAddr);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (filterServerList != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                       <span class="built_in">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="built_in">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">masterAddr</span> <span class="operator">=</span> brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                   <span class="keyword">if</span> (masterAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">                       <span class="type">BrokerLiveInfo</span> <span class="variable">brokerLiveInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                       <span class="keyword">if</span> (brokerLiveInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                           result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                           result.setMasterAddr(masterAddr);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.lock.writeLock().unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;registerBroker Exception&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该方法是处理Broker心跳包的最核心方法，它主要做了对RouteInfoManager路由信息的一些更新操作，包括对clusterAddrTable、brokerAddrTable、topicQueueTable、brokerLiveTable等路由信息。</p>
<h2 id="Broker路由注册时序图"><a href="#Broker路由注册时序图" class="headerlink" title="Broker路由注册时序图"></a>Broker路由注册时序图</h2><p><img src="/images/post-RocketMQ-NameServer/20190525092557.png"></p>
<h1 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h1><p>前面部分我们分析了Nameserver启动时会创建一个定时任务，定时剔除不活跃的Broker。<br><b>org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager.scanNotActiveBroker()</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scanNotActiveBroker</span><span class="params">()</span> &#123;</span><br><span class="line">       Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="built_in">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">           <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> next.getValue().getLastUpdateTimestamp();</span><br><span class="line">           <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">               RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">               it.remove();</span><br><span class="line">               log.warn(<span class="string">&quot;The broker channel expired, &#123;&#125; &#123;&#125;ms&quot;</span>, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class="line">               <span class="built_in">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>剔除Broker信息的逻辑就比较简单了，就是遍历所有存活的Broker的信息，也就是BrokerLiveInfo，从BrokerLiveInfo获取状态信息，判断Broker的心跳时间是否已经超过限定值，如果超过，则执行剔除的逻辑。<br>这个逻辑，会放在Namesrv初始化方法initialize()里以一个定时任务来执行，默认每隔10秒执行一次。</p>
<h1 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h1><p>RocketMQ路由发现，是非实时的。当Topic路由出现变化后，Namesrv不主动推送给客户端，而是由客户端定时拉取主题最新的路由。<br>根据主题名称拉取路由信息的命令编码为： GET ROUTEINTO BY_TOPIC 。RocketMQ 路由结果如下：</p>
<p>•	String orderTopicConf ：顺序消息配置内容，来自于kvConfig 。<br>•	List&lt;QueueData&gt; queueData ： topic 队列元数据。<br>•	List&lt;BrokerData&gt; brokerDatas ： topic 分布的broker 元数据。<br>•	HashMap&lt; String&#x2F;* brokerAdress*&#x2F;,List&lt;String&gt; &#x2F;* filterServer* &#x2F;&gt; ： broker 上过滤服务器地址列表</p>
<p>NameServer 路由发现实现方法：<br><b>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor.getRouteInfoByTopic(ChannelHandlerContext, RemotingCommand)</b></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">       RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> RemotingCommand.createResponseCommand(<span class="literal">null</span>);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">GetRouteInfoRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span></span><br><span class="line">           (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line"></span><br><span class="line">       <span class="type">TopicRouteData</span> <span class="variable">topicRouteData</span> <span class="operator">=</span> <span class="built_in">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (topicRouteData != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">orderTopicConf</span> <span class="operator">=</span></span><br><span class="line">                   <span class="built_in">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                       requestHeader.getTopic());</span><br><span class="line">               topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">           response.setBody(content);</span><br><span class="line">           response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">           response.setRemark(<span class="literal">null</span>);</span><br><span class="line">           <span class="keyword">return</span> response;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">       response.setRemark(<span class="string">&quot;No topic route info in name server for the topic: &quot;</span> + requestHeader.getTopic()</span><br><span class="line">           + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Step 1：调用RouterlnfoManager 的方法，从路由表topicQueueTable 、brokerAddrTable 、filterServerTable 中分别填充TopicRouteData 中的List&lt;QueueData&gt;、List&lt;BrokerData&gt;和 filterServer 地址表。<br>Step 2 ： 如果找到主题对应的路由信息并且该主题为顺序消息，则从NameServerKVconfig 中获取关于顺序消息相关的配置填充路由信息。如果找不到路由信息CODE 则使用TOPIC NOT_EXISTS ，表示没有找到对应的路由。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要介绍了NameServer 路由功能，包含路由元数据、路由注册与发现机制。<br>下面以一张图来总结Namesrv的路由注册、删除机制。<br><img src="/images/post-RocketMQ-NameServer/20190525093816.png"></p>
<p>Namesrv路由发现与删除机制的设计，主要是，消息生产者（Producer）在发送消息之前先从Namesrv获取Broker服务器地址列表，然后根据负载算法从列表中选择一台消息服务器进行发送 。Namesrv与每台Broker服务器保持长连接，Broker每隔30秒（可配置，默认30秒）发送一次心跳向Namesrv报告自己存活，而Namesrv则间隔10秒检测一次Broker是否存活（对比上一次报告时间是否超过120秒），如果检测到Broker宕机，则从路由注册表（BrokerLiveInfo）中将其移除。<br>但是这样的设计存在这样一种情况： NameServer 需要等Broker 失效至少120秒才能将该Broker 从路由表中移除掉，那如果在Broker 故障期间，因为没有立马把路由变化通知到消息生产者，消息生产者Producer 根据主题获取到的路由信息包含已经看机的Broker ，会导致消息发送失败，那这种情况怎么办，岂不是消息发送不是高可用的？这个其实是在<a href="/2019/05/30/RocketMQ-Producer-Send-Message/#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息发送端提供容错机制来保证消息的高可用性的</a>， 这样的设计，主要是为了降低Namesrv实现的复杂性。<br>而Namesrv本身的高可用，可以通过部署多台Namesrv服务器来实现，但彼此之间互不通信，这一点，跟我们熟悉的zookeeper，etcd这种不一样（namesrv不像zk那样分leader&#x2F;follower，或者说master&#x2F;slave，强调的更多是CAP里的AP，避免脑裂问题），这其实也是RocketMQ的namesrv设计的一个亮点，因为不需要维护master、slave的状态同步，所以实现更加简单。<br>从以上亮点，可以看出，RocketMQ的Namesrv设计上追求简单高效。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#消息队列" >
    <span class="tag-code">消息队列</span>
  </a>

  <a href="/tags#分布式" >
    <span class="tag-code">分布式</span>
  </a>

  <a href="/tags#异步" >
    <span class="tag-code">异步</span>
  </a>

  <a href="/tags#削峰" >
    <span class="tag-code">削峰</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/05/18/RocketMQ-Debug-Environment/">
        <span class="nav-arrow">← </span>
        
          RocketMQ调试环境配置
        
      </a>
    
    
      <a class="nav-right" href="/2019/05/30/RocketMQ-Producer-Send-Message/">
        
          RocketMQ-Producer消息发送
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <!--<div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>-->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83Namesrv%E8%AE%BE%E8%AE%A1"><span class="toc-nav-text">路由中心Namesrv设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-nav-text">路由元信息</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Namesrv%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B8%80%E8%A7%88"><span class="toc-nav-text">Namesrv实现类一览</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Namesrv%E5%90%AF%E5%8A%A8"><span class="toc-nav-text">Namesrv启动</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%88%9B%E5%BB%BANamesrvController%E5%AF%B9%E8%B1%A1"><span class="toc-nav-text">创建NamesrvController对象</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%90%AF%E5%8A%A8NamesrvController"><span class="toc-nav-text">启动NamesrvController</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-nav-text">路由启动时序图</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C"><span class="toc-nav-text">路由注册</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Broker%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-nav-text">Broker发送心跳包</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#NameSrv%E5%A4%84%E7%90%86%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-nav-text">NameSrv处理心跳包</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Broker%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-nav-text">Broker路由注册时序图</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E5%88%A0%E9%99%A4"><span class="toc-nav-text">路由删除</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%91%E7%8E%B0"><span class="toc-nav-text">路由发现</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-nav-text">小结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/05/25/RocketMQ-NameServer/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fgu123";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RocketMQ NameServer",
        owner: "fgu123",
        repo: "fgu123.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2019/05/25/RocketMQ-NameServer/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2024 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>