<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="ppxu&#39;s blog">
  <meta name="keyword" content="java, blog, article">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      RocketMQ消息存储 | PPXu
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PPXu</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/search" class="item-link">Search</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/search" class="menu-link">Search</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RocketMQ消息存储</h2>
  <p class="post-date">2019-06-02</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="存储概要设计"><a href="#存储概要设计" class="headerlink" title="存储概要设计"></a>存储概要设计</h1><p>每个Broker都对应有一个MessageStore，专门用来存储发送到它的消息，不过MessageStore本身不是文件，只是存储的一个抽象，MessageStore 中保存着一个 CommitLog，CommitLog 维护了一个 MappedFileQueue，而MappedFileQueue 中又维护了多个 MappedFile，每个MappedFile都会映射到文件系统中一个文件，这些文件才是真正的存储消息的地方，MappedFile的文件名为它记录的第一条消息的全局物理偏移量。</p>
<p><img src="/images/post-RocketMQ-Message-Storage/20190602114015.png" alt=""></p>
<h1 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h1><p>Broker对于每个请求 Code，都注册了对应的处理类，其中用于接收消息的处理类为：org.apache.rocketmq.broker.processor.SendMessageProcessor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line"><span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br><span class="line"><span class="keyword">this</span>.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="keyword">this</span>.sendMessageExecutor);</span><br></pre></td></tr></table></figure>
<p>SendMessageProcessor实现了 org.apache.rocketmq.remoting.netty.NettyRequestProcessor 接口，并在接口方法processRequest()中处理接收到的请求，SendMessageProcessor在processRequest()中调用了sendMessage()方法来进行消息处理。</p>
<figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.broker.processor.SendMessageProcessor.processRequest(ChannelHandlerContext, RemotingCommand)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h1><h2 id="SendMessageProcessor-sendMessage"><a href="#SendMessageProcessor-sendMessage" class="headerlink" title="SendMessageProcessor-sendMessage()"></a>SendMessageProcessor-sendMessage()</h2><p>接收到消息请求后，就要处理请求了，上面调用了sendMessage()来处理消息<br><b>SendMessageProcessor 中 sendMessage() 中主要分为下面几步：</b></p>
<ol>
<li><p>根据收到请求，封装成内部消息结构：MessageExtBrokerInner。</p>
<figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.broker.processor.SendMessageProcessor.sendMessage(ChannelHandlerContext, RemotingCommand, SendMessageContext, SendMessageRequestHeader)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">msgInner.setQueueId(queueIdInt);</span><br><span class="line">		</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">msgInner.setBody(body);</span><br><span class="line">msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="keyword">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 Broker 中 的MessageStore的putMessage() 方法，将消息放入MessageStore中。</p>
<figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.broker.processor.SendMessageProcessor.sendMessage(ChannelHandlerContext, RemotingCommand, SendMessageContext, SendMessageRequestHeader)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>正如前面所述，每个Broker都有一个MessageStore实例，MessageStore本身是一个接口，定义了一些用来存储消息的接口协议，RocketMQ中MessageStore默认的实现类为DefaultMessageStore，Broker在其初始化方法initialize()中便会初始化好DefaultMessageStore。</p>
<h2 id="DefaultMessageStore-putMessage"><a href="#DefaultMessageStore-putMessage" class="headerlink" title="DefaultMessageStore-putMessage()"></a>DefaultMessageStore-putMessage()</h2><p>DefaultMessageStore 中 putMessage() 逻辑又分为下面几步：<br>1). 检查当前Broker是否可以存储消息，比如 MessageStore 被关闭、Broker 状态为 Slave 都会拒绝存储。</p>
<figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.store.DefaultMessageStore.putMessage(MessageExtBrokerInner)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">          log.warn(<span class="string">"message store has shutdown, so putMessage is forbidden"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">          <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">          <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              log.warn(<span class="string">"message store is slave mode, so putMessage is forbidden "</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>2). 检查消息合法性，比如消息的Topic长度和内容长度是否超出限制。这种情况下也会拒绝存储。<br><figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.store.DefaultMessageStore.putMessage(MessageExtBrokerInner)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">	log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">	log.warn(<span class="string">"putMessage message properties length too long "</span> + msg.getPropertiesString().length());</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3). 如果消息通过了上面的重重考验，便会被提交给 MessageStore 中的 CommitLog，进行下一步处理。<br><figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.store.DefaultMessageStore.putMessage(MessageExtBrokerInner)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure></p>
<p>消息到了CommitLog后，便要开始进入存储逻辑了。我们来看看CommitLog中是如何处理消息的。</p>
<h2 id="CommitLog-PutMessage"><a href="#CommitLog-PutMessage" class="headerlink" title="CommitLog-PutMessage()"></a>CommitLog-PutMessage()</h2><ol>
<li><p>获取写锁，保证同一时刻只处理一条消息的存储操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putMessageLock.lock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>从CommitLog的Message 中获取最新的MappedFile，追加消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>前面介绍到，CommitLog 中保存了一个MappedFileQueue，MappedFileQueue 初始化的时候配置了消息文件MappedFile的存储路径以及单个MappedFile文件的大小，当某个消息文件写满后，便会生成一个新的MappedFile继续写入消息，所以MappedFileQueue中会按照消息写入时间顺序，维护多个MappedFile。</p>
<ol start="3">
<li>消息追加结束后，释放写锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putMessageLock.unlock();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><b>上面这几步中，重点关注的是第2步，即将消息追加到当前最新的MappedFile中。</b></p>
<p>上面追加消息调用的是MappedFile.appendMessage()方法，此方法最终调用到MappedFile.appendMessagesInner() 中：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.MappedFile.appendMessagesInner(MessageExt, AppendMessageCallback)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">          ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">          byteBuffer.position(currentPos);</span><br><span class="line">          AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">              result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">              result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">          <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      log.error(<span class="string">"MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;"</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>获取MappedFile中的 writeBuffer，如果 writeBuffer 为空，则获取mappedByteBuffer。</p>
<blockquote><p>在MessageStore初始化的时候，会初始化一个Buffer缓存池：TransientStorePool，TransientStorePool在初始化时会初始化若干DirectBuffer，放入一个Deque中，默认池子容量为5。MappedFile的writeBuffer就是从这个池子中获取的。<br>而 mappedByteBuffer 类型为MappedByteBuffer，前面说到每个MappedFile都会映射到文件系统中的一个文件，mappedByteBuffer 即为该文件在内存中的映射。<br>当追加消息到MappedFile中，会优先追加到 writeBuffer中。</p>
</blockquote>
</li>
<li><p>调用 cb.doAppend()追加消息，调用该方法时，传入了下面几个参数</p>
<blockquote><p>this.getFileFromOffset()：MappedFile的全局消息物理偏移量（即MappedFile中第一个消息全局物理偏移量，也是MappedFile的文件名）。<br>byteBuffer：即MappedFile的内存缓冲区，也即是 1 中的writeBuffer或mappedByteBuffer。<br>this.fileSize - currentPos：fileSize为单个文件的额定大小，默认为1GB，currentPos为当前文件中已经写到什么位置，两个相减即为当前文件剩余容量。<br>(MessageExtBrokerInner) messageExt：这个没什么好说的，就是内部封装好的消息</p>
</blockquote>
</li>
</ol>
<p>cb 从哪来的呢？前面CommitLog在调用appendMessagesInner()时，传入的 cb 为：this.appendMessageCallback，它的类型为 DefaultAppendMessageCallback，实现了AppendMessageCallback接口。所以我们接下来就要看看DefaultAppendMessageCallback中对于doAppend()的实现即可。</p>
<p>doAppend() 主要逻辑如下：</p>
<ol>
<li><p>计算消息存储的各个属性，如消息长度，消息在消息队列中的长度等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record ConsumeQueue information</span></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line">keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">String key = keyBuilder.toString();</span><br><span class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断消息追加后是否超过单个MappedFile大小，如果超出，则返回状态码：AppendMessageStatus.END_OF_FILE</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determines whether there is sufficient free space</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 CommitLog 会新创建一个MappedFile，重新追加消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">        unlockMappedFile = mappedFile;</span><br><span class="line">        <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">        mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">            log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">        &#125;</span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>序列化消息内容，存储到内存缓存区中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialization of storage space</span></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</span><br><span class="line"><span class="comment">// 1 TOTALSIZE</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgLen);</span><br><span class="line"><span class="comment">// 2 MAGICCODE</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</span><br><span class="line"><span class="comment">// 3 BODYCRC</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</span><br><span class="line"><span class="comment">// 4 QUEUEID</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</span><br><span class="line"><span class="comment">// 5 FLAG</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</span><br><span class="line"><span class="comment">// 6 QUEUEOFFSET</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(queueOffset);</span><br><span class="line"><span class="comment">// 7 PHYSICALOFFSET</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</span><br><span class="line"><span class="comment">// 8 SYSFLAG</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</span><br><span class="line"><span class="comment">// 9 BORNTIMESTAMP</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</span><br><span class="line"><span class="comment">// 10 BORNHOST</span></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));</span><br><span class="line"><span class="comment">// 11 STORETIMESTAMP</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</span><br><span class="line"><span class="comment">// 12 STOREHOSTADDRESS</span></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));</span><br><span class="line"><span class="comment">//this.msgBatchMemory.put(msgInner.getStoreHostBytes());</span></span><br><span class="line"><span class="comment">// 13 RECONSUMETIMES</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</span><br><span class="line"><span class="comment">// 14 Prepared Transaction Offset</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</span><br><span class="line"><span class="comment">// 15 BODY</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putInt(bodyLength);</span><br><span class="line"><span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.put(msgInner.getBody());</span><br><span class="line"><span class="comment">// 16 TOPIC</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put((<span class="keyword">byte</span>) topicLength);</span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.put(topicData);</span><br><span class="line"><span class="comment">// 17 PROPERTIES</span></span><br><span class="line"><span class="keyword">this</span>.msgStoreItemMemory.putShort((<span class="keyword">short</span>) propertiesLength);</span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.put(propertiesData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回追加成功的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line">msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="文件存储及刷盘策略"><a href="#文件存储及刷盘策略" class="headerlink" title="文件存储及刷盘策略"></a>文件存储及刷盘策略</h1><p>RocketMQ支持的刷盘策略有两种：</p>
<ol>
<li><p>同步刷盘<br>同步的意思就是说当消息追加到内存后，就立即刷到文件中存储。</p>
</li>
<li><p>异步刷盘<br>当消息追加到内存中，并不是理解刷到文件中，而是在后台任务中进行异步操作。</p>
</li>
</ol>
<p>RocketMQ默认采用异步刷盘策略。</p>
<p>当CommitLog在putMessage()中收到MappedFile成功追加消息到内存的结果后，便会调用handleDiskFlush()方法进行刷盘，将消息存储到文件中。handleDiskFlush() 便会根据两种刷盘策略，调用不同的刷盘服务。</p>
<figure class="highlight java"><figcaption><span><b>org.apache.rocketmq.store.CommitLog.CommitLog(DefaultMessageStore)</b></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> GroupCommitService();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> FlushRealTimeService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h2><p>同步刷盘的服务为GroupCommitService，主要逻辑如下：</p>
<ol>
<li><p>handleDiskFlush()中提交刷盘请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"></span><br><span class="line">GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">service.putRequest(request);</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步等待刷盘结果，刷盘失败也会标志消息存储失败，返回 FLUSH_DISK_TIMEOUT</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"><span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">  log.error(<span class="string">"do groupcommit, wait for flush failed, topic: "</span> + messageExt.getTopic() + <span class="string">" tags: "</span> + messageExt.getTags()</span><br><span class="line">      + <span class="string">" client address: "</span> + messageExt.getBornHostString());</span><br><span class="line">  putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>进行同步刷盘的服务为 GroupCommitService，当请求被提交给GroupCommitService后，GroupCommitService并不是立即处理，而是先放到内部的一个请求队列中，并利用waitPoint通知新请求到来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(<span class="keyword">final</span> GroupCommitRequest request)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsWrite) &#123;</span><br><span class="line">          <span class="keyword">this</span>.requestsWrite.add(request);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">          waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 GroupCommitService 被唤醒后，便会将 requestsWrite 中的请求交换到 requestsRead中，避免产生锁竞争。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;GroupCommitRequest&gt; tmp = <span class="keyword">this</span>.requestsWrite;</span><br><span class="line">    <span class="keyword">this</span>.requestsWrite = <span class="keyword">this</span>.requestsRead;</span><br><span class="line">    <span class="keyword">this</span>.requestsRead = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GroupCommitService 在启动后会在死循环中调用doCommit()方法，而doCommit()则不断遍历requestsRead中的请求，进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这里最终调用了CommitLog.this.mappedFileQueue.flush(0) 来进行刷盘。</p>
<p>同步刷盘的任务虽然也是在异步线程中执行，但是消息存储的主流程中会同步等待刷盘结果，所以本质上还是同步操作。</p>
<h2 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h2><p>同步刷盘的服务为FlushRealTimeService，不过当内存缓存池TransientStorePool 可用时，消息会先提交到TransientStorePool 中的WriteBuffer内部，再提交到MappedFile的FileChannle中，此时异步刷盘服务就是 CommitRealTimeService，它继承自 FlushRealTimeService。</p>
<p>我们别管那么多，先看看FlushRealTimeService中的主要逻辑吧：</p>
<ol>
<li><p>handleDiskFlush()中直接唤醒异步刷盘服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushCommitLogService.wakeup();</span><br></pre></td></tr></table></figure>
</li>
<li><p>FlushRealTimeService 在启动后，会在死循环中周期性的进行刷盘操作，主要逻辑如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">    <span class="comment">// 休眠策略，为 true 时，调用 Thread.sleep()休眠，为false时，调用wait()休眠，默认 false</span></span><br><span class="line">    <span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取刷盘周期，默认为 500 ms</span></span><br><span class="line">    <span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line">    <span class="comment">// 每次刷盘至少要刷多少页内容，每页大小为 4 k，默认每次要刷 4 页</span></span><br><span class="line">    <span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line">    <span class="comment">// 两次刷写之间的最大时间间隔，默认 10 s</span></span><br><span class="line">    <span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line">        CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> printFlushProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print flush progress</span></span><br><span class="line">    <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 判断当前时间距离上次刷盘时间是否已经超出设置的两次刷盘最大间隔</span></span><br><span class="line">    <span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">        <span class="comment">// 如果已经超时，则将flushPhysicQueueLeastPages设置为0，表明将所有内存缓存全部刷到文件中</span></span><br><span class="line">        flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">        printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据不同休眠策略，进行休眠等待</span></span><br><span class="line">        <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">            Thread.sleep(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (printFlushProgress) &#123;</span><br><span class="line">            <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 休眠结束，开始执行刷盘操作</span></span><br><span class="line">        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line">        <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> past = System.currentTimeMillis() - begin;</span><br><span class="line">        <span class="keyword">if</span> (past &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"Flush data to disk costs &#123;&#125; ms"</span>, past);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上面这段逻辑可知，异步刷盘就在异步线程中，周期性的将内存缓冲区的内容刷到文件中，在消息主流程中，只会唤醒异步刷盘线程，而不会同步等待刷盘结果，所以称为异步刷盘。</p>
<h2 id="MappedFile的刷盘"><a href="#MappedFile的刷盘" class="headerlink" title="MappedFile的刷盘"></a>MappedFile的刷盘</h2><p>两种刷盘策略，最终都调用了下面这个方法进行刷盘<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br></pre></td></tr></table></figure></p>
<p>是时候看看mappedFileQueue.flush()中做了什么了。</p>
<ol>
<li>从mappedFileQueue保存的所有MappedFile中，找出所要刷盘的MappedFile</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>flushedWhere 记录了最后一条被刷到文件的内容的全局物理偏移量。所以此次刷盘就要根据偏移量，找到本次要刷盘的起始点位于哪个MappedFile。</p>
<ol start="2">
<li>如果找到了对应的MappedFile，则对该MappedFile中的内容执行刷盘操作，并更新flushedWhere。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">    <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class="line">    <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">    result = where == <span class="keyword">this</span>.flushedWhere;</span><br><span class="line">    <span class="keyword">this</span>.flushedWhere = where;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == flushLeastPages) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷盘的终极目的地就在MappedFile的flush()方法中，具体也分为下面几步：</p>
<ol>
<li>判断是否满足刷盘条件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>isAbleToFlush()其实就是判断当前剩余未刷盘内容长度，是否超过最小刷盘长度：flushLeastPages，避免不必要的刷盘操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAbleToFlush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.flushedPosition.get();</span><br><span class="line">    <span class="keyword">int</span> write = getReadPosition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flushLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如果满足刷盘条件，则将内存中的内容刷到文件中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果writeBuffer不为空，则表明消息是先提交到writeBuffer中，已经从writeBuffer提交到fileChannel，直接调用fileChannel.force()</span></span><br><span class="line"><span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">// 反之，消息是直接存储在文件内存映射缓冲区mappedByteBuffer中，直接调用它的force()即可</span></span><br><span class="line">    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到这儿，消息就成功的从内存中存储到文件内部了。</p>
<h1 id="消息索引"><a href="#消息索引" class="headerlink" title="消息索引"></a>消息索引</h1><h2 id="ConsumerQueue"><a href="#ConsumerQueue" class="headerlink" title="ConsumerQueue"></a>ConsumerQueue</h2><p>RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储（CommitLog）所有Topic的消息，从而保证消息存储是完全的顺序写，这是写消息的高性能所在，但是这样给文件读取带来了不便，试想一下如果消费者直接从CommitLog中去遍历查找所订阅的Topic下的消息，效率将极其低下。为了适应消息消费的检索需求，RocketMQ设计了消息消费队列文件（ConsumeQueue），ConsumeQueue可以看成是CommitLog关于消息消费的“索引”文件，ConsumeQueue的第一级目录为Topic，第二级目录为Topic底下的消息队列（MessageQueue）。</p>
<p>为了加速 ConsumeQueue 消息条目的检索速度与节省磁盘空间，每一个 ConsumeQueue 条目不会存储消息的全量信息，它存储自己所属Topic的消息在CommitLog中的偏移量，这样当消费者从Broker拉取消息的时候，就可以快速根据偏移量定位到消息，其存储格式如图所示<br><img src="/images/post-RocketMQ-Message-Storage/20190602121037.png" alt=""></p>
<p>单个 ConsumeQueue 文件默认包含30万个条目，也就是说单个文件的长度为30W x 20 字节。单个ConsumeQueue文件可以看作是一个 ConsumeQueue 条目的数组，数组下标为 ConsumeQueue 的逻辑偏移量，消息消费进度存储的偏移量即逻辑偏移量。</p>
<p>ConsumeQueue 构建机制是当消息到达 Commitlog 文件后 由专门的线程产生消息转发任务，从而构建消息消费队列文件与下文提到的索引文件。</p>
<p>ConsumeQueue本身同样是利用MappedFileQueue进行记录偏移量信息的，可见MappedFileQueue的设计多么美妙，它没有与消息进行耦合，而是设计成一个通用的存储功能。</p>
<p>先来看一下ConsumeQueue根据消息逻辑偏移量、时间戳查找消息的实现。</p>
<h3 id="根据消息逻辑偏移量查找消息"><a href="#根据消息逻辑偏移量查找消息" class="headerlink" title="根据消息逻辑偏移量查找消息"></a>根据消息逻辑偏移量查找消息</h3><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.ConsumeQueue.getIndexBuffer(long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">       <span class="keyword">long</span> offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">       <span class="keyword">if</span> (offset &gt;= <span class="keyword">this</span>.getMinLogicOffset()) &#123;</span><br><span class="line">           MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">           <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">               SelectMappedBufferResult result = mappedFile.selectMappedBuffer((<span class="keyword">int</span>) (offset % mappedFileSize));</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>根据 startIndex 获取消息消费队列条目。首先 startIndex * 20 算得在 consumeQueue 中的物理偏移 ，如果该 offset 小于 minLogicOffset，则返回 null，说明该消息已被删除；如果大于 minLogicOffset，则根据偏移量定位到具体的物理文件，然后通过 offset 与物理文大小取模获取在该文件的偏移，从而从偏移量开始连续读取 20个字节即可。</p>
<h3 id="根据时间戳查找消息"><a href="#根据时间戳查找消息" class="headerlink" title="根据时间戳查找消息"></a>根据时间戳查找消息</h3><p>由于方法代码篇幅较长，以下分段进行解析</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.ConsumeQueue.getOffsetInQueueByTime(long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOffsetInQueueByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getMappedFileByTime(timestamp);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = minLogicOffset &gt; mappedFile.getFileFromOffset() ? (<span class="keyword">int</span>) (minLogicOffset - mappedFile.getFileFromOffset()) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> midOffset = -<span class="number">1</span>, targetOffset = -<span class="number">1</span>, leftOffset = -<span class="number">1</span>, rightOffset = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> leftIndexValue = -<span class="number">1L</span>, rightIndexValue = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">long</span> minPhysicOffset = <span class="keyword">this</span>.defaultMessageStore.getMinPhyOffset();</span><br><span class="line">        SelectMappedBufferResult sbr = mappedFile.selectMappedBuffer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != sbr) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = sbr.getByteBuffer();</span><br><span class="line">            high = byteBuffer.limit() - CQ_STORE_UNIT_SIZE;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>首先根据时间戳定位到物理文件，其具体实现就是从首个文件开始找，直到找到首次出现更新时间大于该时间戳的文件。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.ConsumeQueue.getOffsetInQueueByTime(long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (high &gt;= low) &#123;</span><br><span class="line">                    midOffset = (low + high) / (<span class="number">2</span> * CQ_STORE_UNIT_SIZE) * CQ_STORE_UNIT_SIZE;</span><br><span class="line">                    byteBuffer.position(midOffset);</span><br><span class="line">                    <span class="keyword">long</span> phyOffset = byteBuffer.getLong();</span><br><span class="line">                    <span class="keyword">int</span> size = byteBuffer.getInt();</span><br><span class="line">                    <span class="keyword">if</span> (phyOffset &lt; minPhysicOffset) &#123;</span><br><span class="line">                        low = midOffset + CQ_STORE_UNIT_SIZE;</span><br><span class="line">                        leftOffset = midOffset;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> storeTime =</span><br><span class="line">                        <span class="keyword">this</span>.defaultMessageStore.getCommitLog().pickupStoreTimestamp(phyOffset, size);</span><br><span class="line">                    <span class="keyword">if</span> (storeTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (storeTime == timestamp) &#123;</span><br><span class="line">                        targetOffset = midOffset;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (storeTime &gt; timestamp) &#123;</span><br><span class="line">                        high = midOffset - CQ_STORE_UNIT_SIZE;</span><br><span class="line">                        rightOffset = midOffset;</span><br><span class="line">                        rightIndexValue = storeTime;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        low = midOffset + CQ_STORE_UNIT_SIZE;</span><br><span class="line">                        leftOffset = midOffset;</span><br><span class="line">                        leftIndexValue = storeTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>采用二分查找来加速检索。首先计算最低查找偏移量，取<b>消息队列最小偏移量</b>与<b>该文件最小偏移量</b>二者中的较小者作为low，获得当前存储文件中有效的最小消息物理偏移量minPhysicOffset，如果查找到消息偏移量小于该物理偏移量，则结束该查找过程。<br>二分查找的常规退出循环的条件为（ low &gt; high ），首先查找中间的偏移量 midOffset，将 ConsumeQueue 文件对应的 ByteBuffer 定位到 midOffset ，然后读取4个字节获取该消息的物理偏移量 offset。<br>1) 如果得到的物理偏移量小于当前的最小物理偏移量，说明待查找的物理偏移量肯定大于 midOffset，所以将 low 设置为 midOffset ，然后继续折半查找；<br>2) 如果 offset 大于最小物理偏移，说明该消息是有效消息，则根据消息偏移量和消息长度获取消息的存储时间戳；<br>3) 如果存储时间小于0，消息为无效消息，直接返回0；<br>4) 如果存储时间戳等于待查找时间戳，说明查找到匹配消息，设置 targetOffset 并跳出循环；<br>5) 如果存储时间戳大于待查找时间戳，说明待查找信息小于 midOffset ，则设置 high 为 midOffset 并设置 rightlndexValue 等于 midOffset；<br>6) 如果存储时间小于待查找时间戳，说明待查找消息在大于 midOffset ，则设置 low 为 midOffset ，并设置 leftIndexValue 等于 midOffset。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.ConsumeQueue.getOffsetInQueueByTime(long)				</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (targetOffset != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    offset = targetOffset;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leftIndexValue == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        offset = rightOffset;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightIndexValue == -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        offset = leftOffset;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        offset =</span><br><span class="line">                            Math.abs(timestamp - leftIndexValue) &gt; Math.abs(timestamp</span><br><span class="line">                                - rightIndexValue) ? rightOffset : leftOffset;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (mappedFile.getFileFromOffset() + offset) / CQ_STORE_UNIT_SIZE;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sbr.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 targetOffset 不等于-1，表示找到了存储时间戳等于待查找时间的消息；如果 leftIndexValue 等于-1，表示返回比当前时间戳大并且最接近待查找时间的偏移量；如果 rightIndexValue 等于-1，表示返回的消息比待查找时间戳小并且最接近查找的偏移量。</p>
<h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><p>因为ConsumeQueue中没有存储消息ID，如果我们需要根据消息ID来查找消息，那么，在不采取其它措施来查找消息的情况下，就又得遍历CommitLog文件了，于是，为了满足这个需求，RocketMQ采用了索引文件（IndexFile）。</p>
<p>RocketMQ引入了Hash索引机制为消息建立索引，HashMap的设计，包含两个基本点：Hash槽与解决Hash冲突的链表结构。IndexFile布局如图</p>
<p><img src="/images/post-RocketMQ-Message-Storage/20190602122806.png" alt=""></p>
<p>消息的索引信息是存放在磁盘上的，文件以时间戳命名的，默认存放在 $ROCKETMQ_HOME/store/index 目录下。由上图来看，一个索引文件的结构被分成了三部分:</p>
<ul>
<li>前 40 个字节存放固定的<b>索引头(IndexHeader)</b>信息，包含了存放在这个索引文件中的消息的<b>最小/大存储时间</b>、<b>最小/大偏移量</b>等状况</li>
<li>中间一段存储了 500 万个哈希槽位，每个槽内部存储的是索引文件的地址 (索引槽)</li>
<li>最后一段存储了 2000 万个索引内容信息，是实际的索引信息存储的地方。每一个槽位存储了这条消息的键哈希值、存储偏移量、存储时间戳与下一个索引槽地址</li>
</ul>
<p>事实上，RocketMQ 在<b>内存中</b>还维护了一个<b>索引文件列表</b>，对于每一个索引文件，前一个文件的最大存储时间是下一个文件的最小存储时间，前一个文件的最大偏移量是下一个文件的最小偏移量。每一个索引文件都索引了在某个时间段内、某个偏移量段内的所有消息，当文件满了，就会用前一个文件的最大偏移量和最大存储时间作为起始值，创建下一个索引文件:</p>
<p><img src="/images/post-RocketMQ-Message-Storage/20190602123214.png" alt=""></p>
<h3 id="IndexFile文件的数据写入"><a href="#IndexFile文件的数据写入" class="headerlink" title="IndexFile文件的数据写入"></a>IndexFile文件的数据写入</h3><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexFile.putKey(String, long, long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key topic + uniqKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> phyOffset 物理偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> storeTimestamp</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1、判断index是否已满，返回失败</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">           <span class="comment">//2、计算key的非负数hashCode</span></span><br><span class="line">           <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">           <span class="comment">//3、key应该存放的slot keyHash % 500W</span></span><br><span class="line">           <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">           <span class="comment">//3、slot的数据存放位置 40 + keyHash %（500W）* 4</span></span><br><span class="line">           <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">           FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize,</span></span><br><span class="line">               <span class="comment">// false);</span></span><br><span class="line">               <span class="comment">//5、如果存在hash冲突，获取这个slot存的前一个index的计数，如果没有则值为0</span></span><br><span class="line">               <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">               <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                   slotValue = invalidIndex;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//6、计算当前msg的存储时间和第一条msg相差秒数</span></span><br><span class="line">               <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">               <span class="comment">//这里为了节约空间；直接timestamp是8位</span></span><br><span class="line">               timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                   timeDiff = Integer.MAX_VALUE;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//7、获取该条index实际存储position</span></span><br><span class="line">               <span class="comment">//40 + 500W * 4 + index的顺序数 * 40；</span></span><br><span class="line">               <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                   IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                       + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//8、Index Linked list</span></span><br><span class="line">               <span class="comment">//topic+message key的hash值</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">               <span class="comment">//消息在CommitLog的物理文件地址, 可以直接查询到该消息(索引的核心机制)</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">               <span class="comment">//消息的落盘时间与header里的beginTimestamp的差值(为了节省存储空间，如果直接存message的落盘时间就得8bytes)</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">               <span class="comment">//9、记录该slot上一个index</span></span><br><span class="line">               <span class="comment">//hash冲突处理的关键之处, 相同hash值上一个消息索引的index(如果当前消息索引是该hash值的第一个索引，则prevIndex=0, 也是消息索引查找时的停止条件)，每个slot位置的第一个消息的prevIndex就是0的</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//Slot Table</span></span><br><span class="line">               <span class="comment">//4字节</span></span><br><span class="line">               <span class="comment">//10、记录该slot当前index，如果hash冲突（即absSlotPos一致）作为下一次该slot新增的前置index</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">               <span class="comment">//11、如果是第一条消息，更新header中的起始offset和起始time</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//12、累计indexHeader</span></span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       fileLock.release();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">               + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中，第5步判断slot的值是否存在，如存在则hash冲突，则在第9步把value设置为当前index的前一个index，到第10步将slot的值设置为当前index，这里有点类似HashMap的链表操作。值得注意的一点是，IndexFile 条目中存储的不<br>是消息索引 key 而是消息属性 key 的 HashCode ，在 根据 key 查找时需要根据消息物理偏移量找到消息进而再验证消息 key 的值，之所以只存储 Hash Code 而不存储具体的 key 是为了将 Index 目设计为定长结构，才 能方便地检索 与定位条目。</p>
<h3 id="索引文件检索"><a href="#索引文件检索" class="headerlink" title="索引文件检索"></a>索引文件检索</h3><p>索引生成的key是topic#MessageKey，所以两者作为参数传递进去查询消息<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexService.queryOffset(String, String, int, long, long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> topic 按topic维度来查询消息，因为索引生成的时候key是用的topic#MessageKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key MessageKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maxNum 最多返回的消息数，因为key是由用户设置的，并不保证唯一，所以可能取到多个消息；同时index中只存储了hash，所以hash相同的消息也会取出来</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> begin 起始时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> end 结束时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> QueryOffsetResult <span class="title">queryOffset</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">       List&lt;Long&gt; phyOffsets = <span class="keyword">new</span> ArrayList&lt;Long&gt;(maxNum);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> indexLastUpdateTimestamp = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> indexLastUpdatePhyoffset = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//不会超过64条</span></span><br><span class="line">       maxNum = Math.min(maxNum, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch());</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.readWriteLock.readLock().lock();</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.indexFileList.isEmpty()) &#123;</span><br><span class="line">               <span class="comment">//1、从最后一个文件开始往前查找，最后一个文件是最新的</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.indexFileList.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                   IndexFile f = <span class="keyword">this</span>.indexFileList.get(i - <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">boolean</span> lastFile = i == <span class="keyword">this</span>.indexFileList.size();</span><br><span class="line">                   <span class="keyword">if</span> (lastFile) &#123;</span><br><span class="line">                       indexLastUpdateTimestamp = f.getEndTimestamp();</span><br><span class="line">                       indexLastUpdatePhyoffset = f.getEndPhyOffset();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//2、判断index文件的时间包含了begin和end的全部或者部分</span></span><br><span class="line">                   <span class="keyword">if</span> (f.isTimeMatched(begin, end)) &#123;</span><br><span class="line">                       <span class="comment">//3、从index文件中获取offset</span></span><br><span class="line">                       f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (f.getBeginTimestamp() &lt; begin) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"queryMsg exception"</span>, e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.readWriteLock.readLock().unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>物理偏移量查找<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexFile.selectPhyOffset(List<long>, String, int, long, long, boolean)</long></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> begin, <span class="keyword">final</span> <span class="keyword">long</span> end, <span class="keyword">boolean</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFile.hold()) &#123;</span><br><span class="line">        <span class="comment">//1、计算key的非负数hashCode</span></span><br><span class="line">        <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">        <span class="comment">//2、key应该存放的slot keyHash % 500W</span></span><br><span class="line">        <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">        <span class="comment">//3、slot的数据存放位置 40 + keyHash %（500W）* 4</span></span><br><span class="line">        <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">        FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos,</span></span><br><span class="line">                <span class="comment">// hashSlotSize, true);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、获取slot最后存储的index位置进行回溯</span></span><br><span class="line">            <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">            <span class="comment">// if (fileLock != null) &#123;</span></span><br><span class="line">            <span class="comment">// fileLock.release();</span></span><br><span class="line">            <span class="comment">// fileLock = null;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                || <span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nextIndexToRead = slotValue; ; ) &#123;</span><br><span class="line">                    <span class="comment">//5、查询条目满足则返回</span></span><br><span class="line">                    <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//6、获取该条index实际存储position</span></span><br><span class="line">                    <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                        IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                            + nextIndexToRead * indexSize;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> keyHashRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">                    <span class="comment">//7、物理偏移量即commitLog的offset</span></span><br><span class="line">                    <span class="keyword">long</span> phyOffsetRead = <span class="keyword">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//当前msg的存储时间和第一条msg相差秒数</span></span><br><span class="line">                    <span class="keyword">long</span> timeDiff = (<span class="keyword">long</span>) <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">                    <span class="keyword">int</span> prevIndexRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> timeRead = <span class="keyword">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">                    <span class="keyword">boolean</span> timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//8、hash一致并且时间在begin和end之间，加入结果集中</span></span><br><span class="line">                    <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">                        phyOffsets.add(phyOffsetRead);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//9、读取到0，说明没数据可读</span></span><br><span class="line">                    <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex</span><br><span class="line">                        || prevIndexRead &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                        || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//10、前一条不等于0，继续读取前一条，往前回溯</span></span><br><span class="line">                    nextIndexToRead = prevIndexRead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"selectPhyOffset exception "</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileLock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mappedFile.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实时更新消息消费队列和索引文件"><a href="#实时更新消息消费队列和索引文件" class="headerlink" title="实时更新消息消费队列和索引文件"></a>实时更新消息消费队列和索引文件</h1><p>消息消费队列文件（ConsumeQueue）和消息属性索引文件（IndexFile）都是基于CommitLog文件构建的，当Producer提交消息存储到CommitLog文件中，consumeQueue和IndexFile需要及时更新，保证消息消费的及时性。而RocketMQ是通过开启一个线程ReputMessageService来做到准实时转发CommitLog文件更新的事件请求，而监听事件变化的相应的任务处理器根据转发的消息及时更新ConsumeQueue与IndexFile。更新流程如下：</p>
<p><img src="/images/post-RocketMQ-Message-Storage/20190602124152.png" alt=""></p>
<p>由org.apache.rocketmq.store.DefaultMessageStore.start()得知，每个Broker在启动时，会启动ReputMessageService线程，并初始化一个非常关键的参数reputFromOffset。该参数的含义是ReputMessageService从哪个物理偏移量开始转发消息给ConsumeQueue和IndexFile。如果允许重复转发，reputFromOffset设置为CommitLog的提交指针；如果不允许重复转发，reputFromOffset设置为CommitLog在内存中的最大偏移量。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.DefaultMessageStore.start()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure>
<p>如上图所示，ReputMessageService线程每执行1次任务推送后，休眠1ms即继续尝试推送更新任务到ConsumeQueue及IndexFile，任务转发的核心实现在doReput(…)方法中实现，其主要逻辑主要如下：</p>
<ol>
<li>返回reputFromOffset偏移量开始的全部有效数据（commitlog 文件），然后循环读取每一条消息。</li>
<li>从SelectMappedBufferResult返回的ByteBuffer中循环读取消息，一次读取一条，创建DispatchRequest对象，如果消息长度大于0，则调用doDispatch方法，最终分别调用CommitLogDispatcherBuildConsumeQueue（构建消息消费队列）、CommitLogDispatcherBuildlndex（构建索引文件）。接下来看下这两者的具体实现。</li>
</ol>
<h2 id="根据消息更新ConsumeQueue"><a href="#根据消息更新ConsumeQueue" class="headerlink" title="根据消息更新ConsumeQueue"></a>根据消息更新ConsumeQueue</h2><p>ConsumeQueue转发任务实现类为 CommitLogDispatcherBuildConsumeQueue，内部终将调用 putMessagePositionInfo(DispatchRequest) 方法</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.DefaultMessageStore.putMessagePositionInfo(DispatchRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">    ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Topic及队列ID，先获取对应的ConsumeQueue文件，其逻辑比较简单，因为每个Topic对应一个ConsumeQueue目录，然后Topic下每个消息队列对应一个文件夹，然后Topic下每个消息队列对应一个文件夹，然后取出该文件夹最后的ConsumeQueue文件即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line"><span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次将消息偏移量、消息长度、 tag_hashcode 写入到 ByteBuffer 中，并根据consumeQueueOffset计算ConsumeQueue中的物理地址，将内容追加到ConsumeQueue的内存映射文件（MappedFile，但本操作只追加并不刷盘），ConsumeQueue的刷盘方式固定为异步刷盘模式。</p>
<h2 id="根据消息更新IndexFile"><a href="#根据消息更新IndexFile" class="headerlink" title="根据消息更新IndexFile"></a>根据消息更新IndexFile</h2><p>Hash 索引文件转发任务实现类为 CommitLogDispatcherBuildIndex</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.DefaultMessageStore.CommitLogDispatcherBuildIndex.dispatch(DispatchRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">		DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由以上代码可知，支持由配置方式，透过设置messageIndexEnable为true，来决定是否调用重建索引服务，也就是IndexService.buildIndex方法。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexService.buildIndex(DispatchRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">      <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">          DispatchRequest msg = req;</span><br><span class="line">          String topic = msg.getTopic();</span><br><span class="line">          String keys = msg.getKeys();</span><br><span class="line">          <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>获取或创建 IndexFile 文件并获取所有文件最大的物理偏移量 如果该消息的物理偏移量小于索引文件中的物理偏移，则说明是重复数据，忽略本次索引构建。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexService.buildIndex(DispatchRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">    <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息的唯一键不为空，则添加到 Hash 索引中，以便加速根据唯一键检索消息。</p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.index.IndexService.buildIndex(DispatchRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                    String key = keyset[i];</span><br><span class="line">                    <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                        <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>构建索引键， RocketMQ 支持为同一个消息建立多个索引，多个索引键空格分开。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>RocketMQ 主要存储文件包含消息文件（Commitlog）、消息消费队列文件（ConsumeQueue）、 Hash 索引文件 （IndexFile ）等。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ 组织文件以文件的起始偏移量来命名文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘与异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的数据刷写到磁盘。当消息到达 Commitlog 文件后，会通过 ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。<br><br><br><b>大神总结的RocketMQ消息存储的总体架构图如下：</b></p>
<p><img src="/images/post-RocketMQ-Message-Storage/20190602130327.png" alt=""></p>
<blockquote>
<p>RocketMQ采用的这种存储结构，我们可以理解成<b>混合型</b>存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。而Kafka采用的是独立型的存储结构，每个队列一个文件。这种混合型结构的缺点在于，随机读的操作较多，降低读消息的效率，于是RocketMQ使用ConsumeQueue文件及IndexFile文件辅助消息读取、查找，而这样也要付出一定的开销及维护代价。为此，RocketMQ为提高读写性能，把系统中所有I/O请求，都通过Page Cache机制实现，Page Cache本身可以对数据文件进行预读取。<br>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型直接将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了）。</p>
</blockquote>
<p>最后，附上大神总结的RocketMQ文件存储模型结构图：<br><img src="/images/post-RocketMQ-Message-Storage/20190602130618.png" alt=""></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>《RocketMQ技术内幕》丁威<br><a href="https://zhuanlan.zhihu.com/p/59516998" target="_blank" rel="noopener">RocketMQ源码分析之ConsumeQueue</a><br><a href="https://www.jianshu.com/p/b73fdd893f98" target="_blank" rel="noopener">消息中间件—RocketMQ消息存储（一）</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#消息队列" >
    <span class="tag-code">消息队列</span>
  </a>

  <a href="/tags#分布式" >
    <span class="tag-code">分布式</span>
  </a>

  <a href="/tags#异步" >
    <span class="tag-code">异步</span>
  </a>

  <a href="/tags#削峰" >
    <span class="tag-code">削峰</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/05/30/RocketMQ-Producer-Send-Message/">
        <span class="nav-arrow">← </span>
        
          RocketMQ-Producer消息发送
        
      </a>
    
    
      <a class="nav-right" href="/2019/06/08/RocketMQ-Message-Consumer/">
        
          RocketMQ-Consumer消息消费
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <!--<div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>-->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#存储概要设计"><span class="toc-nav-text">存储概要设计</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#消息接收"><span class="toc-nav-text">消息接收</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#消息存储"><span class="toc-nav-text">消息存储</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#SendMessageProcessor-sendMessage"><span class="toc-nav-text">SendMessageProcessor-sendMessage()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#DefaultMessageStore-putMessage"><span class="toc-nav-text">DefaultMessageStore-putMessage()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#CommitLog-PutMessage"><span class="toc-nav-text">CommitLog-PutMessage()</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#文件存储及刷盘策略"><span class="toc-nav-text">文件存储及刷盘策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#同步刷盘"><span class="toc-nav-text">同步刷盘</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#异步刷盘"><span class="toc-nav-text">异步刷盘</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MappedFile的刷盘"><span class="toc-nav-text">MappedFile的刷盘</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#消息索引"><span class="toc-nav-text">消息索引</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ConsumerQueue"><span class="toc-nav-text">ConsumerQueue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#根据消息逻辑偏移量查找消息"><span class="toc-nav-text">根据消息逻辑偏移量查找消息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#根据时间戳查找消息"><span class="toc-nav-text">根据时间戳查找消息</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#索引文件"><span class="toc-nav-text">索引文件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#IndexFile文件的数据写入"><span class="toc-nav-text">IndexFile文件的数据写入</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#索引文件检索"><span class="toc-nav-text">索引文件检索</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#实时更新消息消费队列和索引文件"><span class="toc-nav-text">实时更新消息消费队列和索引文件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#根据消息更新ConsumeQueue"><span class="toc-nav-text">根据消息更新ConsumeQueue</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#根据消息更新IndexFile"><span class="toc-nav-text">根据消息更新IndexFile</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#小结"><span class="toc-nav-text">小结</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Reference"><span class="toc-nav-text">Reference</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/06/02/RocketMQ-Message-Storage/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fgu123";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RocketMQ消息存储",
        owner: "fgu123",
        repo: "fgu123.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2019/06/02/RocketMQ-Message-Storage/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>