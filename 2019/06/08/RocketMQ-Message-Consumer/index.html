<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="ppxu&#39;s blog">
  <meta name="keyword" content="java, blog, article">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      RocketMQ-Consumer消息消费 | PPXu
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>PPXu</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/search" class="item-link">Search</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/search" class="menu-link">Search</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RocketMQ-Consumer消息消费</h2>
  <p class="post-date">2019-06-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>消息被Producer发送到Broker后，消息消费端consumer既可请求broker拉取消息并开展消费处理。消息消费以组（Consumer Group）的模式开展，一个消费组内可以包含多个消费者，每一个Consumer Group可订阅多个Topic，Consumer Group之间有两种消费模式：广播模式（BROADCASTING）、集群模式（CLUSTERING）。</p>
<ul>
<li>集群模式：主题下的同一条消息只允许被其中一个消费者消费。</li>
<li>广播模式：主题下的同一条消息将被集群内的所有消费者消费一次。</li>
</ul>
<p>Broker与Consumer之间的消息传送方式也有两种：</p>
<ul>
<li>拉模式：Consumer主动向Broker请求拉取消息</li>
<li>推模式：Broker将消息推送给Consumer，事实上推模式的实现基于拉模式，在拉模式上包装一层而已，详细实现下文展示。<br>先来看一下，Consumer的启动过程。</li>
</ul>
<h1 id="Consumer启动"><a href="#Consumer启动" class="headerlink" title="Consumer启动"></a>Consumer启动</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">            <span class="comment">// 1. 检验consumer配置</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 实例化mqClientFactory</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line">            <span class="comment">// 3. 设置rebalance相关属性</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">            <span class="comment">// 4. 设置pullAPIWrapper的消息过滤钩子</span></span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line">            <span class="comment">// 5. 设置consumer的offsetStore参数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line">            <span class="comment">// 6. 根据consumer设置的messageListner不同子类实例化不同的consumeMessageService,然后启动该类代表的线程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="comment">// 7. 注册当前的consumer</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8. 启动各种线程任务（这里还启动了netty客户端）</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();  <span class="comment">//9、直接执行reblance逻辑(也就是决定consumer的负载均衡)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体步骤如下：</p>
<h2 id="1-校验consumer的配置"><a href="#1-校验consumer的配置" class="headerlink" title="1.校验consumer的配置"></a>1.校验consumer的配置</h2><p>其实就是校验consumer设置的值是否正确，consumer重要参数如下：</p>
<ul>
<li>messageModel:消费消息的模式(广播模式和集群模式）</li>
<li>consumeFromWhere:选择起始消费位置的方式</li>
<li>allocateMessageQueueStrategy:分配具体messageQuene的策略子类。（负载均衡逻辑实现的关键类）</li>
<li>consumeThreadMin：消费消息线程池的最小核心线程数(默认20)</li>
<li>consumeThreadMax：最大线程数（默认64）</li>
<li>pullInterval：拉取消息的间隔，默认是0</li>
<li>consumeMessageBatchMaxSize：每批次消费消息的条数，默认为1</li>
<li>pullBatchSize：每批次拉取消息的条数，默认32</li>
</ul>
<h2 id="2-例化mQClientFactory"><a href="#2-例化mQClientFactory" class="headerlink" title="2.例化mQClientFactory"></a>2.例化mQClientFactory</h2><p>我们从实例化mQClientFactory代码可以看出：一个consumer客户端只会对应一个mQClientFactory（因为factoryTable存放的mQClientFactory是以客户端作为key存放的），也就是说一个应用节点只会有一个mQClientFactory实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    <span class="comment">//factoryTable存放的就是client的实例，key为clientid。</span></span><br><span class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        instance =<span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),<span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-设置reblance相关属性"><a href="#3-设置reblance相关属性" class="headerlink" title="3.设置reblance相关属性"></a>3.设置reblance相关属性</h2><p>也就是设置该consumer对应的负载均衡策略需要的相关参数，例如messageModel、allocateMessageQueueStrategy、实例化mQClientFactory等。</p>
<h2 id="4-设置pullAPIWrapper的消息过滤钩子"><a href="#4-设置pullAPIWrapper的消息过滤钩子" class="headerlink" title="4.设置pullAPIWrapper的消息过滤钩子"></a>4.设置pullAPIWrapper的消息过滤钩子</h2><p>此步作用在于可以由用户自己指定consumer过滤消息的策略，只需要调用consumer的registerFilterMessageHook，将自己实现的过滤消息的FilterMessageHook设置给consumer即可。</p>
<h2 id="5-设置consumer的offsetStore"><a href="#5-设置consumer的offsetStore" class="headerlink" title="5.设置consumer的offsetStore"></a>5.设置consumer的offsetStore</h2><p>也就是设置consumer使用哪种处理消息消费位置offset的类。<br>如果是广播消费模式，则选择LocalFileOffsetStore；<br>如果是集群消费模式，则选择RemoteBrokerOffsetStore；</p>
<h2 id="6-设置consumer的consumeMessageService"><a href="#6-设置consumer的consumeMessageService" class="headerlink" title="6.设置consumer的consumeMessageService"></a>6.设置consumer的consumeMessageService</h2><p>根据consumer设置的MessageListener来决定使用具体ConsumeMessageService。<br>如果是MessageListenerOrderly，则使用代表顺序消息消费的service：ConsumeMessageOrderlyService；<br>如果是MessageListenerConcurrently，则使用非顺序消息service：ConsumeMessageConcurrentlyService。</p>
<p>PS：此步还调用了consumeMessageService的start方法，这里只是启动了一个定时线程去做cleanExpireMsg的操作，并没有启动消费消息的线程。</p>
<h2 id="7-注册当前的consumer"><a href="#7-注册当前的consumer" class="headerlink" title="7.注册当前的consumer"></a>7.注册当前的consumer</h2><p>这里只是将当前consumer放到了一个缓存map中，key为consumerGroup的名称。</p>
<h2 id="8-mQClientFactory-start"><a href="#8-mQClientFactory-start" class="headerlink" title="8.mQClientFactory.start"></a>8.mQClientFactory.start</h2><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.factory.MQClientInstance.start()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Start request-response channel</span></span><br><span class="line">                <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                <span class="comment">// Start various schedule tasks</span></span><br><span class="line">                <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                <span class="comment">// Start pull service</span></span><br><span class="line">                <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                <span class="comment">// Start rebalance service</span></span><br><span class="line">                <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                <span class="comment">// Start push service</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                log.info(<span class="string">"the client factory [&#123;&#125;] start OK"</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The Factory object["</span> + <span class="keyword">this</span>.getClientId() + <span class="string">"] has been created before, and failed."</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this.mQClientAPIImpl.start()启动了netty客户端，用于处理Consumer的网络请求。<br>this.startScheduledTask()启动了一个线程池来安排执行各种定时任务，包括以下：</p>
<ul>
<li>MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr();</li>
<li>MQClientInstance.this.updateTopicRouteInfoFromNameServer();</li>
<li>MQClientInstance.this.cleanOfflineBroker();</li>
<li>MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();</li>
<li>MQClientInstance.this.persistAllConsumerOffset();</li>
<li>MQClientInstance.this.adjustThreadPool();<br>至于，this.pullMessageService.start() 与 this.rebalanceService.start() 则启动了另一类独立的线程任务，分别是拉取消息及重新负载均衡。</li>
</ul>
<h2 id="9-触发重新负载均衡"><a href="#9-触发重新负载均衡" class="headerlink" title="9.触发重新负载均衡"></a>9.触发重新负载均衡</h2><p>mQClientFactory.rebalanceImmediately()，点进去看，实际上是调了rebalanceService.wakeup()，唤醒第8步起的重新负载均衡线程。this.rebalanceService.start()点进去看，有一个volatile变量stopped控制rebalanceService是否进入doRebalance()操作。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.common.ServiceThread.start()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Try to start service thread:&#123;&#125; started:&#123;&#125; lastThread:&#123;&#125;"</span>, getServiceName(), started.get(), thread);</span><br><span class="line">    <span class="keyword">if</span> (!started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stopped = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, getServiceName());</span><br><span class="line">    <span class="keyword">this</span>.thread.setDaemon(isDaemon);</span><br><span class="line">    <span class="keyword">this</span>.thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.RebalanceService.run()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">           <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="消息拉取过程"><a href="#消息拉取过程" class="headerlink" title="消息拉取过程"></a>消息拉取过程</h1><p>PullMessageService负责从Broker拉取消息，run()的逻辑看起来很简单：一个while循环不停地从阻塞队列中获取pullRequest，然后执行pullMessage()，这里再次出现了volatile布尔变量stopped，这是一种通用的设计技巧，将stopped声明为volatile，每执行一次业务逻辑检查一下其运行状态是否为停止，可以通过其他线程将stopped设置为true从而停止该线程。this.pullRequestQueue是一个存放消息拉取请求的阻塞队列，如果PullRequestQueue为空，则线程将被阻塞，直到队列里有拉取请求可以take出来。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.PullMessageService.run()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，PullRequest是什么时候被放进去PullRequestQueue里边的呢？接下来详细分析过程。</p>
<h2 id="PullRequestQueue"><a href="#PullRequestQueue" class="headerlink" title="PullRequestQueue"></a>PullRequestQueue</h2><p>这个pullRequestQueue是PullMessageService的私有属性，它存放的PullRequest又是什么结构呢？<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.PullRequest</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从PullRequest类结构看出，pullRequestQueue存放的pullRequest封装的是每一个消费者群组consumerGroup以及对应的消费队列messageQuene，还有消费队列的快照processQueue。</p>
<p>接着，我们跟踪一下其put方法在哪里调用。可以看到，只在PullMessageService.executePullRequestImmediately(PullRequest)方法里边有直接调用<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.PullMessageService.executePullRequestImmediately(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		log.error(<span class="string">"executePullRequestImmediately pullRequestQueue.put"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，我们继续跟踪这个executePullRequestImmediately方法的调用链，就会发现，主要有两类调用入口：Rebalance.run()、DefaultMQPushConsumerImpl.pullMessage的结果回调PullCallback。<br><img src="/images/post-RocketMQ-Message-Consumer/20190608062135.png" alt=""></p>
<h3 id="1-Rebalance-run"><a href="#1-Rebalance-run" class="headerlink" title="1. Rebalance.run()"></a>1. Rebalance.run()</h3><p>RebalanceService顾名思义，就是针对consumer端要消费哪些messageQuene来做重新负载均衡的策略。当consumer集群某个节点挂了，则要考虑重新负载均衡rebalance，将messageQuene重新按照存活的consumer节点进行分配。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.RebalanceImpl.updateProcessQueueTableInRebalance(String, Set<messagequeue>, boolean)</messagequeue></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">	<span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">				log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">			ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">			<span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">			<span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">				<span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">					log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">					PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">					pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">					pullRequest.setNextOffset(nextOffset);</span><br><span class="line">					pullRequest.setMessageQueue(mq);</span><br><span class="line">					pullRequest.setProcessQueue(pq);</span><br><span class="line">					pullRequestList.add(pullRequest); <span class="comment">// 先把需要重新分配的pullRequest放进一个List</span></span><br><span class="line">					changed = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">		<span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest); <span class="comment">// 这里遍历pullRequest，逐个把pullRequest加入到pullRequestQueue</span></span><br><span class="line">		log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面consumer.start过程中，RebalanceService线程会随之启动执行，那么可以理解，当consumer一启动，相应的pullRequestQueue就会存放有pullRequest对象了。</p>
<h3 id="2-PullCallback"><a href="#2-PullCallback" class="headerlink" title="2. PullCallback"></a>2. PullCallback</h3><p>DefaultMQPushConsumerImpl.pullMessage方法里面定义了拉取结果的回调PullCallback，我们得知在PullCallback的onSuccess和onException中调用了pullRequestQueue的put方法。也就是说，RocketMQ保证了每次拉完消息之后都会调用pullRequestQueue的put逻辑。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">    PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                    subscriptionData);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                            pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest); <span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                pullResult.getMsgFoundList(),</span><br><span class="line">                                processQueue,</span><br><span class="line">                                pullRequest.getMessageQueue(),</span><br><span class="line">                                dispatchToConsume);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval()); <span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest); <span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                            || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                            log.warn(</span><br><span class="line">                                <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                                pullResult.getNextBeginOffset(),</span><br><span class="line">                                firstMsgOffset,</span><br><span class="line">                                prevRequestOffset);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest); <span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest); <span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        log.warn(<span class="string">"the pull request offset illegal, &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                            pullRequest.toString(), pullResult.toString());</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                        pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    log.warn(<span class="string">"fix the pull request offset, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                    log.error(<span class="string">"executeTaskLater Exception"</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="number">10000</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                log.warn(<span class="string">"execute the pull request exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 触发调用pullRequestQueue的put逻辑</span></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据以上两个入口我们可以得出结论：<br>当consumer启动时，RebalanceService使得pullRequestQueue有值，PullMessageService的线程不停地从pullRequestQueue中take messageQuene拉取消息处理，处理完之后继续往pullRequestQueue存放messageQuene，从而使得pullRequestQueue不会因为没有值而阻塞。<br>换句话说，<b>pullRequestQueue每次take完一次，都会再继续put messageQuene，将下一次要拉取的pullRequest再次放到pullRequestQueue中，而拉取消息实际又是一个while循环不停去拉取，这样就保证了消费消息的及时性，使得每个Consumer节点仅有一个消息拉取线程负责所有消费者的消息拉取的情况下，不会产生性能瓶颈。</b></p>
<p>OK，到此，总算完成了<b>从阻塞队列pullRequestQueue中拿pullRequest</b>的过程了，接下来，就是根据拿到的pullRequest来进行拉取消息pullMessage了。</p>
<h2 id="this-pullMessage-pullRequest"><a href="#this-pullMessage-pullRequest" class="headerlink" title="this.pullMessage(pullRequest)"></a>this.pullMessage(pullRequest)</h2><p>点进去一直找到实现类的方法org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)，这个方法篇幅比较长，下面逐一拆解<br>此处以获取订阅信息作为拉取消息的正式开始点，那么，在此之前，其实还有两类的关于当前处理队列（processQueue）的状态校验及相关操作首先执行：1.校验并保证处理队列当前执行状态正常，2. 流控。</p>
<h3 id="processQueue执行状态校验"><a href="#processQueue执行状态校验" class="headerlink" title="processQueue执行状态校验"></a>processQueue执行状态校验</h3><p>关于为什么会有ProcessQueue这个数据结构，个人理解，是因为MessageQueue的消费处理其实是并发进行的，那么我们并不能同步获取消息的处理进度，但是本次拉取消息的推进需要根据上一次消费进度来进行，于是就有了ProcessQueue作为MessageQueue的消费处理进度快照。这个类的结构，主要是<b>一个TreeMap及一个读写锁</b>，TreeMap里<b>以MessageQueue的Offset作为Key，以消息内容的引用为Value（所谓快照）</b>，保存所有从MessageQueue获取到，但是还未被处理的消息；读写锁的作用是控制<b>多线程下对TreeMap对象的并发访问</b>。<br>从pullRequest中获取ProcessQueue，如果processQueue当前状态未被丢弃，则更新ProcessQueue的lastPullTimestamp为当前时间戳；如果当前消费者被挂起，则将拉取任务延迟指定时间（PULL_TIME_DELAY_MILLS_WHEN_SUSPEND，1s）后再次放入到PullMessageService的拉取任务队列中，结束本次消息拉取。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line"><span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">          log.info(<span class="string">"the pull request[&#123;&#125;] is dropped."</span>, pullRequest.toString());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">          log.warn(<span class="string">"pullMessage exception, consumer state not ok"</span>, e);</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">          log.warn(<span class="string">"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h3><p>RocketMQ的消息拉取过程的流量控制，是让consumer根据自身的消息处理速度调整获取消息的操作速度，采取的流控处理做法是作延迟一段时间(默认50ms)后消费处理，流控主要从3种维度进行：消息消费数量、消息大小、偏移量间隔。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">      <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              log.warn(</span><br><span class="line">                  <span class="string">"the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">          <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              log.warn(</span><br><span class="line">                  <span class="string">"the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">                  <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">          <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">              <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">              <span class="keyword">if</span> ((queueMaxSpanFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                  log.warn(</span><br><span class="line">                      <span class="string">"the queue's messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">                      processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line">                      pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!pullRequest.isLockedFirst()) &#123;</span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</span><br><span class="line">                  <span class="keyword">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</span><br><span class="line">                  log.info(<span class="string">"the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;"</span>,</span><br><span class="line">                      pullRequest, offset, brokerBusy);</span><br><span class="line">                  <span class="keyword">if</span> (brokerBusy) &#123;</span><br><span class="line">                      log.info(<span class="string">"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;"</span>,</span><br><span class="line">                          pullRequest, offset);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  pullRequest.setLockedFirst(<span class="keyword">true</span>);</span><br><span class="line">                  pullRequest.setNextOffset(offset);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">              log.info(<span class="string">"pull message later because not locked in broker, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>消息消费数量：当前消息处理总数如果超出了指定阈值（1000条）：<b style="color:orange">cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()</b>， 将触发流控，放弃本次拉取任务，并且指定该队列的下一次拉取任务时间间隔为<b>PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL</b>（50ms），每触发1000次流控后输出流控日志。</li>
<li>消息大小：当前消息处理的大小如果超出了指定大小阈值（100MB）：<b style="color:orange">cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()</b>，将触发流控，流控处理与上述的消息消费数量维度的流控处理一致。</li>
<li>偏移量间隔：就是ProcessQueue中最大偏移量与最小偏移量的间距（processQueue.getMaxSpan()，等于<b>maxOffset - minOffset</b>，如下图），当这个间距超过指定阈值（2000）：<b style="color:orange">processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()</b>，就会触发流控，流控处理与上述两种维度的流控处理一致。这个维度的流控设置目的，是为了避免因为一条消息堵塞导致重复消费（下面会细述），不同的是，这里有个前置条件，就是这里只针对非顺序消费模式进行此维度的流控(!this.consumeOrderly)。</li>
</ul>
<p><img src="/images/post-RocketMQ-Message-Consumer/20190608071413.png" alt=""></p>
<p>如图，假如3109为本批次消息消费后的最大偏移量（maxOffset），1093为最小偏移量（minOffset），那么maxSpan=maxOffset-minOffset=3109-1093=2016，大于阈值（2000），则会触发流控，但可能出现上述的这种情况，就是在minOffset后面的很大部分消息实际上已被消费成功，因为下一次的消费偏移量（nextOffset）即为本次minOffset，所以，如果多次消费都是被同一minOffset位置的这个消息阻塞，那么就会引发大量消息重复被消费。而consumeConcurrentlyMaxSpan在这里只是为达到流控目的而把这个间距值限定在一个合适范围而已，但对于解决重复消费的问题，这个作用其实很有限。</p>
<blockquote>
<p>考虑到要是碰上这种极端的情况，一批消息超2K条，实际绝大部分消息都被消费成功，而堵塞前进消费的minOffset那条消息，假设它的消费本身是存在问题的，可能是死循环之类的，那么一直没法成功消费，这就会导致进度一直卡在这条消息这里。其实RocketMQ有现成提供这类问题的解决方案，就是把因为消费超时卡住批量消费进度的消息定义为ExpireMsg，起一个计划线程池，定时执行清掉这些ExpireMsg，清除的具体操作就是把消息重发回去broker，作为延时消息（delayLevel=3，10s）再次存储并后续下发consumer消费。（下文会提到延时消息）</p>
</blockquote>
<h3 id="1-获取订阅信息"><a href="#1-获取订阅信息" class="headerlink" title="1.获取订阅信息"></a>1.获取订阅信息</h3><p>拉取该主题的订阅信息，如果为空，则结束本次消息拉取，同时设置下一次拉取任务的延时为PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION（3s）。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">	<span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">		<span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">		log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="2-构建PullCallback"><a href="#2-构建PullCallback" class="headerlink" title="2.构建PullCallback"></a>2.构建PullCallback</h3><p>构建PullCallback是为了后面请求拉取消息的结果响应处理，其中上一步获取到的订阅信息就是在成功拉取消息后用于处理拉取请求。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">			pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">				subscriptionData);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">				<span class="keyword">case</span> FOUND:</span><br><span class="line">					<span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">					pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">					<span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">					DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">						pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="3-取得要从哪台broker拉取消息的broker地址"><a href="#3-取得要从哪台broker拉取消息的broker地址" class="headerlink" title="3.取得要从哪台broker拉取消息的broker地址"></a>3.取得要从哪台broker拉取消息的broker地址</h3><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(PullRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	...</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">			pullRequest.getMessageQueue(),</span><br><span class="line">			subExpression,</span><br><span class="line">			subscriptionData.getExpressionType(),</span><br><span class="line">			subscriptionData.getSubVersion(),</span><br><span class="line">			pullRequest.getNextOffset(),</span><br><span class="line">			<span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">			sysFlag,</span><br><span class="line">			commitOffsetValue,</span><br><span class="line">			BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">			CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">			CommunicationMode.ASYNC,</span><br><span class="line">			pullCallback</span><br><span class="line">		);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		log.error(<span class="string">"pullKernelImpl exception"</span>, e);</span><br><span class="line">		<span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">```		</span><br><span class="line">	</span><br><span class="line">``` JAVA org.apache.rocketmq.client.impl.consumer.PullAPIWrapper.pullKernelImpl(MessageQueue, String, String, <span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>, CommunicationMode, PullCallback)</span><br><span class="line">	FindBrokerResult findBrokerResult =</span><br><span class="line">		<span class="keyword">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">			<span class="keyword">this</span>.recalculatePullFromWhichNode(mq), <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == findBrokerResult) &#123;</span><br><span class="line">		<span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">		findBrokerResult =</span><br><span class="line">			<span class="keyword">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</span><br><span class="line">				<span class="keyword">this</span>.recalculatePullFromWhichNode(mq), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-构建要拉取消息的网络请求头"><a href="#4-构建要拉取消息的网络请求头" class="headerlink" title="4.构建要拉取消息的网络请求头"></a>4.构建要拉取消息的网络请求头</h3><p>PullAPIWrapper.pullKernelImpl(…)里边调用MQClientAPIImpl.pullMessage(…)，为拉取消息的实际网络请求作准备<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.MQClientAPIImpl.pullMessage(String, PullMessageRequestHeader, long, CommunicationMode, PullCallback)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PullResult <span class="title">pullMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> PullMessageRequestHeader requestHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> PullCallback pullCallback</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="keyword">this</span>.pullMessageAsync(addr, request, timeoutMillis, pullCallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> SYNC:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.pullMessageSync(addr, request, timeoutMillis);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-执行网络层请求broker的代码，根据结果执行对应的回调处理"><a href="#5-执行网络层请求broker的代码，根据结果执行对应的回调处理" class="headerlink" title="5.执行网络层请求broker的代码，根据结果执行对应的回调处理"></a>5.执行网络层请求broker的代码，根据结果执行对应的回调处理</h3><p>深入到网络的调用过程，可以发现本质是交给了netty的work线程去向broker请求拉取消息，拉取到消息之后异步回调拉取的结果。入口代码如下：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.MQClientAPIImpl.pullMessageAsync(String, RemotingCommand, long, PullCallback)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessageAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> PullCallback pullCallback</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> <span class="keyword">throws</span> RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.remotingClient.invokeAsync(addr, request, timeoutMillis, <span class="keyword">new</span> InvokeCallback() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ResponseFuture responseFuture)</span> </span>&#123;</span><br><span class="line">               RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">               <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       PullResult pullResult = MQClientAPIImpl.<span class="keyword">this</span>.processPullResponse(response);</span><br><span class="line">                       <span class="keyword">assert</span> pullResult != <span class="keyword">null</span>;</span><br><span class="line">                       pullCallback.onSuccess(pullResult);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       pullCallback.onException(e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">                       pullCallback.onException(<span class="keyword">new</span> MQClientException(<span class="string">"send request failed to "</span> + addr + <span class="string">". Request: "</span> + request, responseFuture.getCause()));</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseFuture.isTimeout()) &#123;</span><br><span class="line">                       pullCallback.onException(<span class="keyword">new</span> MQClientException(<span class="string">"wait response from "</span> + addr + <span class="string">" timeout :"</span> + responseFuture.getTimeoutMillis() + <span class="string">"ms"</span> + <span class="string">". Request: "</span> + request,</span><br><span class="line">                           responseFuture.getCause()));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       pullCallback.onException(<span class="keyword">new</span> MQClientException(<span class="string">"unknown reason. addr: "</span> + addr + <span class="string">", timeoutMillis: "</span> + timeoutMillis + <span class="string">". Request: "</span> + request, responseFuture.getCause()));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.MQClientAPIImpl.pullMessageSync(String, RemotingCommand, long)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">pullMessageSync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, InterruptedException, MQBrokerException </span>&#123;</span><br><span class="line">    RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(addr, request, timeoutMillis);</span><br><span class="line">    <span class="keyword">assert</span> response != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.processPullResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-执行第一步构建的PullCallback的onSuccess-onException逻辑"><a href="#6-执行第一步构建的PullCallback的onSuccess-onException逻辑" class="headerlink" title="6.执行第一步构建的PullCallback的onSuccess/onException逻辑"></a>6.执行第一步构建的PullCallback的onSuccess/onException逻辑</h3><p>其中onSuccess中，有根据broker响应的不同结果做不同的逻辑处理：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(...).new PullCallback() &#123;...&#125;.onSuccess(PullResult)、org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.pullMessage(...).new PullCallback() &#123;...&#125;.onException(Throwable)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">            subscriptionData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> FOUND:</span><br><span class="line">                <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset(); <span class="comment">// 本次拉取消息的offset</span></span><br><span class="line">                pullRequest.setNextOffset(pullResult.getNextBeginOffset()); <span class="comment">// 设置下一次拉取消息的offset</span></span><br><span class="line">                <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                    pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest); <span class="comment">// 如果没有发现新拉到的消息，将pullRequest放到pullRequestQueue中</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                        pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">								</span><br><span class="line">                    <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(t.getMsgFoundList(),processQueue,pullRequest</span><br><span class="line">                getMessageQueue(),dispatchToConsume);</span><br><span class="line">                <span class="comment">// 把拉取到的消息丢给 processQueue</span></span><br><span class="line">                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                        pullResult.getMsgFoundList(),</span><br><span class="line">                        processQueue,</span><br><span class="line">                        pullRequest.getMessageQueue(),</span><br><span class="line">                        dispatchToConsume); <span class="comment">// 把processQueue丢给ConsumeMessageService，提交消费任务从而让拉取到的消息进行消费</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123; <span class="comment">//判断是否有设置拉取消息的时间间隔，有则走间隔拉取消息的逻辑</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则将pullRequest放到pullRequestQueue中</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                    || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                    log.warn(</span><br><span class="line">                        <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                        pullResult.getNextBeginOffset(),</span><br><span class="line">                        firstMsgOffset,</span><br><span class="line">                        prevRequestOffset);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        log.warn(<span class="string">"execute the pull request exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-将拉取到的消息交给consumeMessageService"><a href="#7-将拉取到的消息交给consumeMessageService" class="headerlink" title="7.将拉取到的消息交给consumeMessageService"></a>7.将拉取到的消息交给consumeMessageService</h3><p>如上一步的部分代码所示，就是交给consumeMessageService代表的消费消息线程池处理，由于消费消息的方式有两种，提交线程池的入口也有两个：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.submitConsumeRequest(List<messageext>, ProcessQueue, MessageQueue, boolean)</messageext></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">    <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">            List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                    msgThis.add(msgs.get(total));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                    msgThis.add(msgs.get(total));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService.submitConsumeRequest(List<messageext>, ProcessQueue, MessageQueue, boolean)</messageext></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，拉到消息后接下来便是消费消息的过程了。当然，在这之前，还有一个指定动作就是将下一次需要拉取的pullRequest再次放到pullRequestQueue中，其用意在上文已有提及。</p>
<h2 id="消息拉取过程小结"><a href="#消息拉取过程小结" class="headerlink" title="消息拉取过程小结"></a>消息拉取过程小结</h2><p>一个consumer客户端会分配一个拉取消息线程（PullMessageService），不停地从存放了messageQuene的阻塞队列中take需要拉取消息的messagequene，最后通过调用通知网络层发起拉取消息拉取的网络请求（实际就是交给netty的worker线程拉消息），netty的worker线程拉取到消息后调用处理PullCallback处理拉取的结果。</p>
<p>由于从broker拉取消息的网络请求交给了netty的worker线程处理，并且work线程处理完之后再异步通知拉取结果处理，我们可以知道pullmessage本身并没有太重的操作，同时每次请求broker拉取消息是批量拉取（默认值是每批32条），因此即使一个consuemr客户端只会有一个线程负责所有consumerGroup，也不会有太慢以及太大的性能瓶颈。</p>
<h1 id="消息消费过程"><a href="#消息消费过程" class="headerlink" title="消息消费过程"></a>消息消费过程</h1><p>ConsumeMessageService是消息消费接口，有两个实现类，分别是顺序消费（ConsumeMessageOrderlyService）及普通消费（ConsumeMessageConcurrentlyService）。无论ConsumeMessageOrderlyService还是ConsumeMessageConcurrentlyService，在核心方法ConsumeMessageService.submitConsumeRequest(…)的实现里都有一个核心逻辑，就是将代表消息实际消费的任务ConsumeRequest，提交给了一个名为ConsumeMessageThread的线程池去异步执行。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.ConsumeMessageConcurrentlyService(DefaultMQPushConsumerImpl, MessageListenerConcurrently)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsumeMessageConcurrentlyService</span><span class="params">(DefaultMQPushConsumerImpl defaultMQPushConsumerImpl,</span></span></span><br><span class="line"><span class="function"><span class="params">    MessageListenerConcurrently messageListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumerImpl = defaultMQPushConsumerImpl;</span><br><span class="line">    <span class="keyword">this</span>.messageListener = messageListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumer = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer();</span><br><span class="line">    <span class="keyword">this</span>.consumerGroup = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup();</span><br><span class="line">    <span class="keyword">this</span>.consumeRequestQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.consumeExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeThreadMin(),</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeThreadMax(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">        TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">this</span>.consumeRequestQueue,</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ConsumeMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ConsumeMessageScheduledThread_"</span>));</span><br><span class="line">    <span class="keyword">this</span>.cleanExpireMsgExecutors = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"CleanExpireMsgScheduledThread_"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，重点就在于ConsumeRequest线程任务的run方法了，而无论ConsumeMessageOrderlyService还是ConsumeMessageConcurrentlyService，核心的消费逻辑基本一致：取得业务方法实现的messageListener，调用其consumeMessage方法，得到处理结果。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.ConsumeRequest.run()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断消息是否已被删除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到messageListener，也就是实际的消息消费业务实现类</span></span><br><span class="line">MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line">defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line"><span class="comment">// 准备消息消费的上下文</span></span><br><span class="line">ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status = listener.consumeMessage(Collections.unmodifiableList(msgs), context); <span class="comment">// 调用消息消费的业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">        RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">        msgs,</span><br><span class="line">        messageQueue);</span><br><span class="line">    hasException = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp; <span class="comment">// 业务消费代码处理时长</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">        returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123; <span class="comment">// 如果消费超时，则有相应处理</span></span><br><span class="line">    returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">    returnType = ConsumeReturnType.FAILED;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">    returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">    log.warn(<span class="string">"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">        msgs,</span><br><span class="line">        messageQueue);</span><br><span class="line">    status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">&#125;</span><br><span class="line">			</span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">    .incConsumeRT(ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line"><span class="comment">// 处理消费消息的结果</span></span><br><span class="line"><span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就看下，messageListener得到消费结果后做的处理：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.processConsumeResult(ConsumeConcurrentlyStatus, ConsumeConcurrentlyContext, ConsumeRequest)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 以下为统计数据记录的操作</span></span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">            <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">            ackIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为针对不同消费模式对消费失败的消息做不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING: <span class="comment">// 广播模式下的消费失败消息处理比较简单，就是遍历失败消息，拿出来之后打个log，默认直接丢弃失败消息就完了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING: <span class="comment">// 集群模式下的失败消息处理</span></span><br><span class="line">            List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context); <span class="comment">// 失败的消息，直接重新发回broker</span></span><br><span class="line">                <span class="keyword">if</span> (!result) &#123; <span class="comment">// 如果发回broker的操作结果还是失败，则放到msgBackFailed列表，下一步继续作处理</span></span><br><span class="line">                    msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                    msgBackFailed.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果msgBackFailed列表不为空，说明上一步有消息在发回broker时发送失败，则走另外的方式处理消费失败的消息：也就是晚一些再重试消费</span></span><br><span class="line">            <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下为更新offset操作，可以看到，不管消息消费成功与否，都会更新consumerGroup消费到的offset</span></span><br><span class="line">    <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>); <span class="comment">// 这里实际上只是更新RemoteBrokerOffsetStore.offsetTable里所存储的offset值，在实现上是通过定时线程发网络请求提交到broker，详见org.apache.rocketmq.client.impl.factory.MQClientInstance.persistAllConsumerOffset()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由以上的消费结果处理基本可以得知：</p>
<ul>
<li>调用业务实现的消费消息逻辑后，得到消费结果，即使消费超时，也最终会根据messageListener执行返回的结果来决定是否重新消费消息。</li>
<li>根据不同的消费模式会对消费失败的结果做不同的处理（实际上按是否顺序消费来划分的两种消息消费模型来看，两者都有不同的消费结果状态定义ConsumeOrderlyStatus、ConsumeConcurrentlyStatus）。对于广播模式，失败消息的处理是直接丢弃；集群模式则会重新消费消息，相应的处理为 1.把消息重新发回Broker，后续作重试处理 2.若发回broker失败，后续作重试消费</li>
<li>关于offset的更新，其实是不管消息消费成功与否，都会有更新consumerGroup所消费到的offset，因为消费失败的消息会作重试处理，其实并不影响offset的更新</li>
</ul>
<p>接下来，便是更新offset及重试消费消息的过程分析了。</p>
<h2 id="offset更新"><a href="#offset更新" class="headerlink" title="offset更新"></a>offset更新</h2><p>无论是LocalFileOffsetStore还是RemoteBrokerOffsetStore，offset更新的逻辑都是一致的：实际上就是每个messageQueue消费到的offset，存放到一个名为offsetTable的内存缓存map里。<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore.updateOffset(MessageQueue, long, boolean)/org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore.updateOffset(MessageQueue, long, boolean)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> increaseOnly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AtomicLong offsetOld = <span class="keyword">this</span>.offsetTable.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == offsetOld) &#123;</span><br><span class="line">            offsetOld = <span class="keyword">this</span>.offsetTable.putIfAbsent(mq, <span class="keyword">new</span> AtomicLong(offset));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != offsetOld) &#123;</span><br><span class="line">            <span class="keyword">if</span> (increaseOnly) &#123;</span><br><span class="line">                MixAll.compareAndIncreaseOnly(offsetOld, offset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offsetOld.set(offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，之后是怎样把这offset更新提交给broker这边的呢？找回consumer启动过程可以定位到，offset的更新，其实是由一个定时线程提交给broker的。就在 org.apache.rocketmq.client.impl.factory.MQClientInstance.start()这个方法里，this.startScheduledTask()启动的若干个定时线程池里，其中有一个就是定时持久化所有consumer的offset变更<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.factory.MQClientInstance.startScheduledTask()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  log.error(<span class="string">"ScheduledTask persistAllConsumerOffset exception"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure></p>
<p>这个定时任务，最终会调用到RemoteBrokerOffsetStore.persistAll(Set<messagequeue>)方法，把offset变更发回Broker<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore.persistAll(Set<messagequeue>)</messagequeue></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistAll</span><span class="params">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mqs || mqs.isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HashSet&lt;MessageQueue&gt; unusedMQ = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!mqs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class="keyword">this</span>.offsetTable.entrySet()) &#123;</span><br><span class="line">            MessageQueue mq = entry.getKey();</span><br><span class="line">            AtomicLong offset = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mqs.contains(mq)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.updateConsumeOffsetToBroker(mq, offset.get()); <span class="comment">// 将offset的更新，发到broker</span></span><br><span class="line">                        log.info(<span class="string">"[persistAll] Group: &#123;&#125; ClientId: &#123;&#125; updateConsumeOffsetToBroker &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                            <span class="keyword">this</span>.groupName,</span><br><span class="line">                            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                            mq,</span><br><span class="line">                            offset.get());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">"updateConsumeOffsetToBroker exception, "</span> + mq.toString(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unusedMQ.add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!unusedMQ.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : unusedMQ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.offsetTable.remove(mq);</span><br><span class="line">            log.info(<span class="string">"remove unused mq, &#123;&#125;, &#123;&#125;"</span>, mq, <span class="keyword">this</span>.groupName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></messagequeue></p>
<p>由于是先消费消息，再提交offset更新，这里有可能存在消费完消息之后，提交offset失败的情况，尽管这种可能性极低，因为提交offset操作实际上只是做了内存的操作，并没有什么重的慢的操作。倒是另外一种情况导致offset更新的丢失的可能性会大很多，因为offset是先存在内存，再通过定时任务间隔数秒走网络请求提交给broker的，这里可能存在譬如这数秒内consumer突然宕机、网络请求失败等因素导致没有成功提交offset到broker，那么在consumer宕机后重启服务，就会出现重复消费消息。<br>综上，<b>在consumer的业务消费代码务必要保证幂等性。</b></p>
<p>而事实上，offset提交broker的操作不是仅仅依赖定时任务完成，在consumer关闭退出时，也会有一次主动触发持久化offset到broker的方法调用（DefaultMQPushConsumerImpl里的shutdown方法也是调的DefaultMQPullConsumerImpl.shutdown()方法）：<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.consumer.DefaultMQPullConsumerImpl.shutdown()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">this</span>.persistConsumerOffset(); <span class="comment">// 在consumer关闭时把offset持久化到broker</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.unregisterConsumer(<span class="keyword">this</span>.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.shutdown();  </span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] shutdown OK"</span>, <span class="keyword">this</span>.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.SHUTDOWN_ALREADY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做，是为了让应用正常退出时，让consumer实例也正常关闭，保证此时也能触发offset更新正确提交到broker。</p>
<h2 id="消费消息重试"><a href="#消费消息重试" class="headerlink" title="消费消息重试"></a>消费消息重试</h2><p>在上文中提到，在消息消费失败后，失败消息会重新发回broker。若重新发送给broker也失败了，那么失败消息会被交给定时任务重新尝试消费。这里看一下broker到底是如何处理消费失败的消息的。<br>在consumerSendMessageBack方法里看到，失败消息重新发回broker使用到的远程请求类型是RequestCode.CONSUMER_SEND_MSG_BACK<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.client.impl.MQClientAPIImpl.consumerSendMessageBack(String, MessageExt, String, int, long, int)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerSendMessageBack</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageExt msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String consumerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> delayLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> maxConsumeRetryTimes</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    ConsumerSendMsgBackRequestHeader requestHeader = <span class="keyword">new</span> ConsumerSendMsgBackRequestHeader();</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>根据这个类型的请求，找到broker处理消费失败的消息的入口：SendMessageProcessor.processRequest(ChannelHandlerContext, RemotingCommand)<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.broker.processor.SendMessageProcessor.processRequest(ChannelHandlerContext, RemotingCommand)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">      SendMessageContext mqtraceContext;</span><br><span class="line">      <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">          <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request); <span class="comment">// 处理重新发回broker消息的请求</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><figcaption><span>org.apache.rocketmq.broker.processor.SendMessageProcessor.consumerSendMsgBack(ChannelHandlerContext, RemotingCommand)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">consumerSendMsgBack</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand request)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">        (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    String namespace = NamespaceUtil.getNamespaceFromResource(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">        ConsumeMessageContext context = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">        context.setNamespace(namespace);</span><br><span class="line">        context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line">        context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line">        context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line">        context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">        context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executeConsumeMessageHookAfter(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">        response.setRemark(<span class="string">"subscription group not exist, "</span> + requestHeader.getGroup() + <span class="string">" "</span></span><br><span class="line">            + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(<span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">"] sending message is forbidden"</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line">    <span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">        topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">        newTopic,</span><br><span class="line">        subscriptionGroupConfig.getRetryQueueNums(),</span><br><span class="line">        PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line">        response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">        response.setRemark(String.format(<span class="string">"the topic[%s] sending message is forbidden"</span>, newTopic));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">"look message by offset failed, "</span> + requestHeader.getOffset());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">        MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">    &#125;</span><br><span class="line">    msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">    <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">        maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes</span><br><span class="line">        || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">        topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">            DLQ_NUMS_PER_GROUP,</span><br><span class="line">            PermName.PERM_WRITE, <span class="number">0</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">            delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(newTopic);</span><br><span class="line">    msgInner.setBody(msgExt.getBody());</span><br><span class="line">    msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">    MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">    msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">    msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">    msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">    msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">    MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">    <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                String backTopic = msgExt.getTopic();</span><br><span class="line">                String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">                <span class="keyword">if</span> (correctTopic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    backTopic = correctTopic;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</span><br><span class="line"></span><br><span class="line">                response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                response.setRemark(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(putMessageResult.getPutMessageStatus().name());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">    response.setRemark(<span class="string">"putMessageResult is null"</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，broker在接收到消费端consumer发回来的失败消息后，会转为延时消息存放起来（因为重试消息是有时间间隔的），利用/的功能，broker端到了延迟的时间点，再将该/转换为重试消息（Topic名转为%RETRY%+consumerGroup），此时consumer端对这些消息重新可见，从而会拉取到该重试消息，达到延迟重复消费的目的。</p>
<h1 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h1><p>延时消息的使用只需要在发送前，指定message的DelayTimeLevel即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"topic"</span>,<span class="string">"msg content"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">msg.setDelayTimeLevel(<span class="number">3</span>); <span class="comment">// 延迟10s</span></span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br></pre></td></tr></table></figure></p>
<p>目前RocketMQ支持的延迟时间有：</p>
<blockquote>
<p>延时 1s    5s    10s    30s    1m    2m    3m    4m    5m    6m    7m    8m    9m    10m    20m    30m    1h    2h，对应的延迟级别（delayTimeLevel）依次为1,2,3,4,5…</p>
</blockquote>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>延迟消息在Producer发送后，在Broker被存放在单独一个Topic：SCHEDULE_TOPIC_XXXX，每一个延迟级别对应该Topic下的一个消费队列，当延迟时间到之时，由定时调度任务（DeliverDelayedMessageTimerTask）读取消息并转换为普通的消息存取到真实指定的Topic下，此时对于consumer端此消息才可见，从而被consumer消费。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 根据支持的各种延迟级别，添加不同延迟时间的TimeTask</span></span><br><span class="line">    <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="keyword">new</span> Timer(<span class="string">"ScheduleMessageTimerThread"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">            Integer level = entry.getKey();</span><br><span class="line">            Long timeDelay = entry.getValue();</span><br><span class="line">            Long offset = <span class="keyword">this</span>.offsetTable.get(level); <span class="comment">// 获取每个延迟级别在普通消费队列中的offset</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">                offset = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个专门执行延迟消息持久化的定时任务</span></span><br><span class="line">        <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心实现在DeliverDelayedMessageTimerTask类，其主要逻辑在于扫描延迟消息SCHEDULE_TOPIC_XXXX的队列下的消息，将延迟消息转换成指定Topic的消息<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask.executeOnTimeup()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConsumeQueue cq =</span><br><span class="line">        ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">            delayLevel2QueueId(delayLevel)); <span class="comment">//读取队列SCHEDULE_TOPIC_XXXX，其中不同的延迟级别对应不同的队列id（queueId=delayLevel-1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">        <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123; <span class="comment">// 循环读取延迟消息</span></span><br><span class="line">                    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">                    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">                            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">                            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                                tagsCode, offsetPy, sizePy);</span><br><span class="line">                            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line"></span><br><span class="line">                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> countdown = deliverTimestamp - now;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123; <span class="comment">// 只有当延迟消息发送的消息到达了才处理</span></span><br><span class="line">                        MessageExt msgExt =</span><br><span class="line">                            ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">                                offsetPy, sizePy); <span class="comment">// 根据offset值读取SCHEDULE_TOPIC_XXXX队列的消息</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt); <span class="comment">// 将读取的消息转换为真实topic的消息（也就是普通消息）</span></span><br><span class="line">                                PutMessageResult putMessageResult =</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.writeMessageStore</span><br><span class="line">                                        .putMessage(msgInner); <span class="comment">// 存放该消息</span></span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span></span><br><span class="line">                                    &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                                    log.error(</span><br><span class="line">                                        <span class="string">"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;"</span>,</span><br><span class="line">                                        msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                                        <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                            nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                        nextOffset);</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                log.error(</span><br><span class="line">                                    <span class="string">"ScheduleMessageService, messageTimeup execute error, drop it. msgExt="</span></span><br><span class="line">                                        + msgExt + <span class="string">", nextOffset="</span> + nextOffset + <span class="string">",offsetPy="</span></span><br><span class="line">                                        + offsetPy + <span class="string">",sizePy="</span> + sizePy, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                            <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset),</span><br><span class="line">                            countdown);</span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// end of for</span></span><br><span class="line">                <span class="comment">// 计算下一次读取延迟队列的offset，是定时任务下一次从该位置读取延时消息</span></span><br><span class="line">                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(</span><br><span class="line">                    <span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE); <span class="comment">// 将下一次读取延迟队列的offset存放到一个缓存map中 </span></span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                bufferCQ.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end of if (bufferCQ != null)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; cqMinOffset) &#123;</span><br><span class="line">                failScheduleOffset = cqMinOffset;</span><br><span class="line">                log.error(<span class="string">"schedule CQ offset invalid. offset="</span> + offset + <span class="string">", cqMinOffset="</span></span><br><span class="line">                    + cqMinOffset + <span class="string">", queueId="</span> + cq.getQueueId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of if (cq != null)</span></span><br><span class="line"></span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">        failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的流程，大致为读取延迟队列的消息，取得消息的开始位置offset，将延迟消息转换为指定topic的普通消息并存起来，修改下一次读取的offset，改的是在内存中的offset而非文件中的，并指定下一次转换延迟消息的TimeTask。</p>
<p>至于持久化offset，在另一个定时任务ScheduleMessageService的persist()方法中实现<br><figure class="highlight java"><figcaption><span>org.apache.rocketmq.common.ConfigManager.persist()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String jsonString = <span class="keyword">this</span>.encode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (jsonString != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String fileName = <span class="keyword">this</span>.configFilePath();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MixAll.string2File(jsonString, fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"persist file "</span> + fileName + <span class="string">" exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，延迟消息的核心实现比之普通消息，只是多了一道将从延迟消息Topic的队列中取出延迟消息以转储到普通消息Topic下的处理，其余逻辑与普通消息无异。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>消息消费部分是实现过程细节众多的一个模块，当中包括消息消费方式、队列重新负载、消息拉取、消费处理、进度存储及同步、定时消息（延迟消息）、保证顺序消费等等。<br>RocketMQ的消息消费方式包括集群模式与广播模式，不同模式有不同的处理逻辑。在拉取消息时会因应不同的消息处理情况作出不同的处理，譬如引发队列的重新负载，根据当前消费组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一时间只会分配给一个消费者。<br>消息拉取由 PullMessageService 线程根据 RebalanceService线程创建的拉取任务进行拉取，默认一批拉取32条消息，提交给消费者消费线程池后继续下一次的消息拉取。<br>如果消息消费过慢产生消息堆积会触发消息消费拉取流控，流控针对的维度目前分别有：消息消费数量、消息大小、偏移量间隔。<br>消息消费是在消费线程池中并发地对同一消息消费队列的消息进行消费，消费成功后，取出消息处理队列中最小的消息偏移量作为消息消费进度偏移量存在于消息消费进度存储文件中，集群模式消息进度存储在 Broker，广播模式消息进度存储在Consumer端。<br>如果业务方返回 RECONSUME_LATER ，则 RocketMQ 启用消息消费重试机制，将原消息的主题与队列存储在消息属性中，将消息存储在主题名为SCHEDULE_TOPIC_XXXX的消息消费队列中，等待指定时间后，RocketMQ自动将该消息重新拉取并再次将消息存储在commitlog进而转发到普通消息消费队列供消费者消费，消息消费重试主题为%RETRY%消费者组名。延迟消息并不支持任意精度的延迟时间调度，只支持定义好的延迟级别，可通过在broker配置文件中设置messageDelayLevel。延迟消息更多地使用在辅助消费的场景下。</p>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/06/02/RocketMQ-Message-Storage/">
        <span class="nav-arrow">← </span>
        
          RocketMQ消息存储
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <!--<div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>-->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Consumer启动"><span class="toc-nav-text">Consumer启动</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-校验consumer的配置"><span class="toc-nav-text">1.校验consumer的配置</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-例化mQClientFactory"><span class="toc-nav-text">2.例化mQClientFactory</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-设置reblance相关属性"><span class="toc-nav-text">3.设置reblance相关属性</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-设置pullAPIWrapper的消息过滤钩子"><span class="toc-nav-text">4.设置pullAPIWrapper的消息过滤钩子</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-设置consumer的offsetStore"><span class="toc-nav-text">5.设置consumer的offsetStore</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-设置consumer的consumeMessageService"><span class="toc-nav-text">6.设置consumer的consumeMessageService</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-注册当前的consumer"><span class="toc-nav-text">7.注册当前的consumer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#8-mQClientFactory-start"><span class="toc-nav-text">8.mQClientFactory.start</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#9-触发重新负载均衡"><span class="toc-nav-text">9.触发重新负载均衡</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#消息拉取过程"><span class="toc-nav-text">消息拉取过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#PullRequestQueue"><span class="toc-nav-text">PullRequestQueue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Rebalance-run"><span class="toc-nav-text">1. Rebalance.run()</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-PullCallback"><span class="toc-nav-text">2. PullCallback</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#this-pullMessage-pullRequest"><span class="toc-nav-text">this.pullMessage(pullRequest)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#processQueue执行状态校验"><span class="toc-nav-text">processQueue执行状态校验</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#流控"><span class="toc-nav-text">流控</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-获取订阅信息"><span class="toc-nav-text">1.获取订阅信息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-构建PullCallback"><span class="toc-nav-text">2.构建PullCallback</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-取得要从哪台broker拉取消息的broker地址"><span class="toc-nav-text">3.取得要从哪台broker拉取消息的broker地址</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-构建要拉取消息的网络请求头"><span class="toc-nav-text">4.构建要拉取消息的网络请求头</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-执行网络层请求broker的代码，根据结果执行对应的回调处理"><span class="toc-nav-text">5.执行网络层请求broker的代码，根据结果执行对应的回调处理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-执行第一步构建的PullCallback的onSuccess-onException逻辑"><span class="toc-nav-text">6.执行第一步构建的PullCallback的onSuccess/onException逻辑</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-将拉取到的消息交给consumeMessageService"><span class="toc-nav-text">7.将拉取到的消息交给consumeMessageService</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消息拉取过程小结"><span class="toc-nav-text">消息拉取过程小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#消息消费过程"><span class="toc-nav-text">消息消费过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#offset更新"><span class="toc-nav-text">offset更新</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#消费消息重试"><span class="toc-nav-text">消费消息重试</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#延时消息"><span class="toc-nav-text">延时消息</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#实现原理"><span class="toc-nav-text">实现原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#具体实现"><span class="toc-nav-text">具体实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#总结"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/06/08/RocketMQ-Message-Consumer/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fgu123";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RocketMQ-Consumer消息消费",
        owner: "fgu123",
        repo: "fgu123.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2019/06/08/RocketMQ-Message-Consumer/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>