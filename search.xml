<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>图解Spring事务传播类型</title>
      <link href="/2019/03/19/Spring-Transaction-Propagation/"/>
      <url>/2019/03/19/Spring-Transaction-Propagation/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring事务传播机制"><a href="#Spring事务传播机制" class="headerlink" title="Spring事务传播机制"></a>Spring事务传播机制</h1><p>Spring管理的事务是逻辑事务，而且物理事务和逻辑事务最大差别就在于事务传播行为，事务传播行为用于指定在多个事务方法间调用时，事务是如何在这些方法间传播的。</p><p></p><p><br>下面以a.save()里调用了b.save()举例，事务方法之间调用时事务如何传播。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.XXX)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">b.save();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.XXX)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-REQUIRED"><a href="#1-REQUIRED" class="headerlink" title="1. REQUIRED"></a>1. REQUIRED</h2><p>默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。如下图：<br><img src="/images/post-Spring-Transaction-Propagation/required-20190319055811.png" alt=""><br>由于两个方法属于同一个物理事务，如果发生回滚，则两者都回滚。</p><h2 id="2-SUPPORTS"><a href="#2-SUPPORTS" class="headerlink" title="2. SUPPORTS"></a>2. SUPPORTS</h2><p>顾名思义就是可以支持事务，如果b.save()在事务环境中运行，则以事务形式运行，否则以非事务运行。<br><strong>注：本文中所有的所谓“非事务”、“无事务”概念其实都是指方法整体不以一个事务单元来执行的意思，譬如，假设b.save()里有多条SQL操作，如果以非事务方式执行b.save()，就意味着，这里边每条SQL操作都是单独一个事务执行，而不是整个方法只起一个事务来执行多条SQL的这种方式。</strong><br><img src="/images/post-Spring-Transaction-Propagation/supports-20190319055812.png" alt=""></p><h2 id="3-MANDATORY"><a href="#3-MANDATORY" class="headerlink" title="3. MANDATORY"></a>3. MANDATORY</h2><p>必须在一个事务中运行，也就是说，b.save()只能在已有事务的方法中被调用，否则会抛异常。<br><img src="/images/post-Spring-Transaction-Propagation/mandatory-20190319055813.png" alt=""></p><h2 id="4-REQUIRES-NEW"><a href="#4-REQUIRES-NEW" class="headerlink" title="4. REQUIRES_NEW"></a>4. REQUIRES_NEW</h2><p>总是会创建一个新事务（包括物理事务），该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。如下图：<br><img src="/images/post-Spring-Transaction-Propagation/requires_new-20190319055814.png" alt=""><br>两个方法之间既不属于同一个逻辑事务也不属于同一个物理事务。</p><h2 id="5-NOT-SUPPORTED"><a href="#5-NOT-SUPPORTED" class="headerlink" title="5. NOT_SUPPORTED"></a>5. NOT_SUPPORTED</h2><p>顾名思义不支持事务，当处于存在事务的上下文环境中运行时，b.save()会暂停当前已开启的事务，意味着a.save()的事务被挂起直至b.save()以非事务方法运行完毕后，a.save()的事务继续执行。<br><img src="/images/post-Spring-Transaction-Propagation/not_supported-20190319055815.png" alt=""></p><h2 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. NEVER</h2><p>绝不能在事务环境中运行，如果a.save()里声明了使用事务，而b.save()的事务类型声明为never，那么只能以抛异常告终。<br><img src="/images/post-Spring-Transaction-Propagation/never-20190319055816.png" alt=""></p><h2 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. NESTED</h2><p>嵌套事务支持。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。<br><img src="/images/post-Spring-Transaction-Propagation/nested-20190319055817.png" alt=""><br>Nested和RequiresNew的区别：</p><ul><li>RequiresNew每次都创建新的独立的物理事务，而Nested只有一个物理事务；Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而RequiresNew由于都是全新的事务，所以之间是无关联的</li><li>Nested使用JDBC 3的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务<br><p><br><strong>使用嵌套事务，必须确保具体事务管理器实现的nestedTransactionAllowed属性为true，否则不支持嵌套事务，如DataSourceTransactionManager默认支持，而HibernateTransactionManager默认不支持，需要我们来开启。</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Transaction </tag>
            
            <tag> Propagation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于页缓存技术提高中间件读写性能的应用</title>
      <link href="/2019/03/17/About-OS-Page-Cache/"/>
      <url>/2019/03/17/About-OS-Page-Cache/</url>
      
        <content type="html"><![CDATA[<h1 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h1><p>在计算机系统中，页面缓存（有时也称为磁盘缓存）是用于源自诸如硬盘驱动器（HDD）或固态驱动器（SSD）的辅助存储设备的页面的透明缓存。操作系统将页面缓存保留在主存储器（RAM，内存）的其他未使用部分中，从而更快地访问缓存页面的内容和达到整体性能改进。页面缓存在具有分页内存管理的内核中实现，并且对应用程序大多是透明的。通常是由操作系统将所有未直接分配给应用程序的物理内存用于页面缓存。</p><p></p><p><br>以linux系统为例，linux中页缓存的本质就是对于磁盘中的部分数据在内存中保留一定的副本，使得应用程序能够快速的读取到磁盘中相应的数据，并实现不同进程之间的数据共享。</p><p></p><p><br>因此，linux中页缓存的引入主要是为了解决两类重要的问题：</p><p>1.磁盘读写速度较慢（ms 级别);</p><p>2.实现不同进程之间或者同一进程的前后不同部分之间对于数据的共享；</p><p></p><p><br>在虚拟内存机制出现以前，操作系统使用块缓存机制，但是在虚拟内存出现以后操作系统管理IO的粒度更大，因此采用了页缓存机制。此后，和后备存储的数据交互普遍以页为单位。页缓存是基于页的、面向文件的一种缓存机制。</p><p></p><p><br>简单来讲，页缓存就是一种副本技术，为加速磁盘读写而在内存中保留的一份磁盘数据的副本，又称为磁盘缓存、文件系统缓存。</p><p></p><p><br>—- <a href="https://en.wikipedia.org/wiki/Page_cache" target="_blank" rel="noopener">Page Cache(From Wikipedia)</a></p><h2 id="页缓存在RocketMQ的应用"><a href="#页缓存在RocketMQ的应用" class="headerlink" title="页缓存在RocketMQ的应用"></a>页缓存在RocketMQ的应用</h2><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p><img src="/images/post-RocketMQ-Summary/20181118164510.jpg" alt=""><br>作为一款纯 Java 语言开发的消息引擎，RocketMQ 自主研发的存储组件，依赖 Page Cache 进行加速和堆积，意味着它的性能会受到 JVM、 GC、内核、Linux 内存管理机制、文件 IO 等因素的影响。Rocketmq中的所有消息都是持久化到硬盘的，但会使用系统PageCache加速访问，消息的落地方式是先写PageCache后刷盘，可以保证内存与磁盘都有一份数据，访问时，可以直接从内存读取。如图所示，一条消息从客户端发送出，到最终落盘持久化。</p><p></p><p><br>—- <a href="/2018/11/18/RocketMQ-Summary/#刷盘策略">RocketMQ相关总结</a></p><h2 id="Kafka的高性能写入"><a href="#Kafka的高性能写入" class="headerlink" title="Kafka的高性能写入"></a>Kafka的高性能写入</h2><h3 id="页缓存技术-磁盘顺序写"><a href="#页缓存技术-磁盘顺序写" class="headerlink" title="页缓存技术 + 磁盘顺序写"></a>页缓存技术 + 磁盘顺序写</h3><p>同RocketMQ的持久化操作的设计类似，Kafka每次接收到数据都会往磁盘上去写，而为了保证数据写入性能，Kafka也是基于操作系统的页缓存来实现文件写入的。</p><p></p><p><br>在消息生产端写入消息时，其实是直接写入到OS Cache（Page Cache）中，也就是说仅仅是写入到内存中，而接下来由操作系统自己决定什么时候把os cache里的数据真的刷入磁盘文件中。</p><p></p><p><br>另外，还有关键的一点，就是kafka写数据的方式是顺序写入，也就是说，仅仅将数据追加到文件的末尾，而不是在文件的随机位置来修改数据。</p><p></p><p><br>—- <a href="http://developer.51cto.com/art/201903/592916.htm" target="_blank" rel="noopener">Kafka如何实现每秒上百万的超高并发写入？</a></p><h2 id="Elastic-Search-准实时搜索"><a href="#Elastic-Search-准实时搜索" class="headerlink" title="Elastic Search 准实时搜索"></a>Elastic Search 准实时搜索</h2><p>Elasticsearch和磁盘之间有一层称为FileSystem Cache的系统缓存（OS Cache），正是由于这层cache的存在才使得es能够拥有更快搜索响应能力。</p><p></p><p><br>我们都知道一个index是由若干个segment组成，随着每个segment的不断增长，我们索引一条数据后可能要经过分钟级别的延迟才能被搜索，为什么有种这么大的延迟，这里面的瓶颈点主要在磁盘。</p><p></p><p><br>持久化一个segment需要fsync操作用来确保segment能够物理的被写入磁盘以真正的避免数据丢失，但是fsync操作比较耗时，所以它不能在每索引一条数据后就执行一次，如果那样索引和搜索的延迟都会非常之大。</p><p></p><p><br>所以这里需要一个更轻量级的处理方式，从而保证搜索的延迟更小。这就需要用到上面提到的FileSystem Cache，所以在es中新增的document会被收集到indexing buffer区后被重写成一个segment然后直接写入filesystem cache中，这个操作是非常轻量级的，相对耗时较少，之后经过一定的间隔或外部触发后才会被flush到磁盘上，这个操作非常耗时。但只要sengment文件被写入cache后，这个sengment就可以打开和查询，从而确保在短时间内就可以搜到，而不用执行一个full commit也就是fsync操作，这是一个非常轻量级的处理方式而且是可以高频次的被执行，而不会破坏es的性能。</p><p></p><p><br>—- <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html" target="_blank" rel="noopener">Elastic Search的近实时搜索</a></p><h2 id="架构的设计思想，本质大同"><a href="#架构的设计思想，本质大同" class="headerlink" title="架构的设计思想，本质大同"></a>架构的设计思想，本质大同</h2><p>由一个页缓存技术的利用可以看出，多个中间件在处理数据高性能读写问题方面的思想基本大同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MiddleWare </tag>
            
            <tag> Cache </tag>
            
            <tag> Kafka </tag>
            
            <tag> Elastic Search </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis分布式锁实现去服务单点问题实践</title>
      <link href="/2019/02/17/Distributed-Lock-HA/"/>
      <url>/2019/02/17/Distributed-Lock-HA/</url>
      
        <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>常见的单个应用服务需要完成某个功能模块，由于业务设计上的原因，该服务只允许一个而不能多个服务实例同时运行。但在高可用架构设计上，这存在单点问题，即一旦主机发生故障，如宕机或网络中断等，而导致服务终止，这种场景下我们希望能采用一种优雅的方式保证服务不中断。于是我们可以采用分布式锁来实现一主多备的高可用方案。</p><h2 id="一主多备"><a href="#一主多备" class="headerlink" title="一主多备"></a>一主多备</h2><p>我们可以实现服务的一主多备模式，有且仅有一个master，至少一个standby，当master节点失败后则由多个standby中选取一个作为主节点继续提供服务。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>考虑到需要有多个服务节点，但同时只允许一个服务节点运行，我们可以实现分布式锁来解决问题。</p><h3 id="分布式锁的几个要求"><a href="#分布式锁的几个要求" class="headerlink" title="分布式锁的几个要求"></a>分布式锁的几个要求</h3><ul><li>最基本要求：互斥性（唯一性），同一时间只能被一个机器节点上的一个线程获得锁。</li><li>避免死锁：可重入性。</li><li>高可用的锁获取及锁释放。</li><li>高性能的锁获取及锁释放。</li><li>阻塞性：最好是一把阻塞锁。</li></ul><h3 id="分布式锁的常见三种实现方式"><a href="#分布式锁的常见三种实现方式" class="headerlink" title="分布式锁的常见三种实现方式"></a>分布式锁的常见三种实现方式</h3><p>分布式锁的常见3种实现方式有基于数据库、缓存及zookeeper的实现，网上一抓有一大把的实现过程可以搜索，此处不详细说明，只简单说明一下各个实现的核心思路及优劣。</p><h4 id="基于数据库的实现方式"><a href="#基于数据库的实现方式" class="headerlink" title="基于数据库的实现方式"></a>基于数据库的实现方式</h4><p>核心思想在于：利用数据库表的唯一索引，以方法名字段作为唯一键，想要执行方法时，使用方法名向表中插入数据，成功则表示获得锁，执行完成后再删除对应的行数据以释放锁。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>思路简单，容易理解。</p><h5 id="问题及优化"><a href="#问题及优化" class="headerlink" title="问题及优化"></a>问题及优化</h5><ol><li>高可用及性能问题：基于数据库实现，数据库的可用性及性能直接影响分布式锁的可用性及性能。数据库要避免单点，需要双机部署、数据同步、主备切换等。</li><li>不可重入：因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据。所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁。</li><li>没有锁失效机制：因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，导致锁一直被占用，不但其它节点无法获得锁，当服务恢复后也一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据。</li><li>非阻塞锁：获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</li></ol><p><strong>注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！</strong> </p><h4 id="基于Zookeeper的实现方式"><a href="#基于Zookeeper的实现方式" class="headerlink" title="基于Zookeeper的实现方式"></a>基于Zookeeper的实现方式</h4><p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p><p>（1）创建一个目录作为锁目录；<br>（2）线程A想获取锁就在锁目录下创建临时顺序节点；<br>（3）获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次序小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p><p><img src="/images/post-Distributed-Lock-HA/20190317213111.jpg" alt=""></p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>Zookeeper是一个分布式协同服务，使用Zookeeper实现分布式锁具有天然优势，最大的优点是API使用简单。</p><p>建议直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        interProcessMutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其它优点：</p><ol><li>解决单点问题：ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li><li>解决不可重入问题：客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>解决锁失效问题：使用ZK可以有效让锁自动失效而释放。在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>解决非阻塞性问题：Watch机制，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>性能问题：性能上不如使用缓存实现分布式锁。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</li><li>并发问题：在网络抖动情况下，客户端与ZK集群的session连接断了，那么zk以为客户端宕掉了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</li></ol><p>建议尽可能的使用Zookeeper来实现分布式协同服务，但如果，业务强依赖于一个Redis集群且服务并没有使用Zookeeper的意愿，不妨可以试试使用Redis。</p><h4 id="基于缓存的实现方式"><a href="#基于缓存的实现方式" class="headerlink" title="基于缓存的实现方式"></a>基于缓存的实现方式</h4><p>各种成熟的缓存产品，包括Redis，memcached以及Tair，分布式锁实现思路基本类似，以Redis举例说明核心思路：<br>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的标识值为一个随机生成的UUID，通过此标识在释放锁的时候进行判断。<br>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。<br>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>性能高是最大优点，基于内存实现的缓存系统。</p><ol><li>解决单点问题：Redis既可单点部署，也支持集群部署。</li><li>解决不可重入问题：在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的持有者。</li><li>解决锁失效问题：设定锁key失效时间。</li><li>非阻塞锁：可以循环多次去执行获取操作，直至获得锁。</li></ol><p>至于失效时间设多久才好？<br>Redisson给出了解决方案–Watchdog看门狗：<br>先获得锁，默认过期时间30秒，如果处理完了，走正常逻辑。 对一个值加锁之后，会在自身维护一个Watchdog后台线程，维护一个内部队列，每过10秒去重新设置一下锁Key的过期时间，这样，一个锁即使对应的进程挂掉，也就维持30秒的时间，如果没有挂，并且30秒不够用了，内部队列会不断的更新这个过期时间为30秒，保证不会出现锁饥饿的问题。<br><br><br>以下为重设Key过期时间的核心方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Future&lt;Boolean&gt; future = expireAsync(internalLockLeaseTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, future.cause());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (future.getNow()) &#123;</span><br><span class="line">                            <span class="comment">// reschedule itself</span></span><br><span class="line">                            scheduleExpirationRenewal();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), task) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><br><br>事实上，使用Redisson，还有一个好处，就是Redisson调Redis命令的底层实现，是使用Lua脚本，这样做，是因为假设有一大坨复杂的业务逻辑，可以通过封装在Lua脚本中发送给Redis，保证这段复杂的业务逻辑执行的原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;Long&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> leaseTime, <span class="keyword">final</span> TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">       internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_LONG,</span><br><span class="line">                           <span class="string">"local mode = redis.call('hget', KEYS[1], 'mode'); "</span> +</span><br><span class="line">                           <span class="string">"if (mode == false) then "</span> +</span><br><span class="line">                                 <span class="string">"redis.call('hset', KEYS[1], 'mode', 'write'); "</span> +</span><br><span class="line">                                 <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                                 <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                                 <span class="string">"return nil; "</span> +</span><br><span class="line">                             <span class="string">"end; "</span> +</span><br><span class="line">                             <span class="string">"if (mode == 'write') then "</span> +</span><br><span class="line">                                 <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                                     <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                                     <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                                     <span class="string">"return nil; "</span> +</span><br><span class="line">                                 <span class="string">"end; "</span> +</span><br><span class="line">                               <span class="string">"end;"</span> +</span><br><span class="line">                               <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                       Arrays.&lt;Object&gt;asList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ol><li>通过超时时间来控制锁的失效时间并非十分的靠谱。譬如在指定的锁Key更新时间内网络抖动导致无法正常失效时间，被认为锁被主节点主动释放了，而实际上并没有，但备节点此时可能已抢得锁，出现多客户端获得锁的问题。</li><li>最大的问题，还是在于Redis的主从集群的复制问题。客户端1对Redis Master写入锁Key的Value，此时会异步复制给Redis Slave。一旦发生Master宕机，Redis主从切换，Slave变成了新的Master，而此时若有客户端2来尝试加锁，在新的Master上完成了加锁，而客户端1也以为自己成功加了锁，此时也出现了多客户端获得锁的问题。</li></ol><h2 id="使用Redis分布式锁去服务单点实践"><a href="#使用Redis分布式锁去服务单点实践" class="headerlink" title="使用Redis分布式锁去服务单点实践"></a>使用Redis分布式锁去服务单点实践</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_ADDRESS = <span class="string">"192.168.4.104:6379"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_PASSWORD = <span class="string">"redis"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_KEY = <span class="string">"redis_lock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithRedisLock</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">RedissonClient redissonClient = RedisUtils.getRedissonClientInstance(</span><br><span class="line">REDIS_ADDRESS, REDIS_PASSWORD);</span><br><span class="line"></span><br><span class="line">RedissonLock lock = (RedissonLock) redissonClient.getLock(LOCK_KEY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步方式尝试Redis加锁操作</span></span><br><span class="line">Future&lt;Boolean&gt; tryLockAsync = lock.tryLockAsync(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 一定要通过调get方法拿到执行加锁的结果，因为是异步方式加锁，调此方法会阻塞直至拿到执行结果</span></span><br><span class="line"><span class="keyword">if</span> (tryLockAsync.get()) &#123;</span><br><span class="line"><span class="comment">// 尝试执行业务逻辑，如果发生异常，则释放锁 </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Application.runApplication(args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">ILOG.error(<span class="string">"run application exception, "</span>, e);</span><br><span class="line"><span class="keyword">if</span>( lock.isHeldByCurrentThread() ) &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ILOG.info(<span class="string">"lock[&#123;&#125;] is being held"</span>, lock.getName());</span><br><span class="line">Application.stopApplication(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">ILOG.error(<span class="string">"lock interrupted exception, "</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">ILOG.error(<span class="string">"lock executed exception, "</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Config;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.SingleServerConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedissonClient <span class="title">getRedissonClientInstance</span><span class="params">(String redisAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">String redisPassword)</span> </span>&#123;</span><br><span class="line">address = redisAddress;</span><br><span class="line">password = redisPassword;</span><br><span class="line"><span class="keyword">return</span> RedissonClientHolder.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonClientHolder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient instance = createRedissonClient(address,</span><br><span class="line">password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient <span class="title">createRedissonClient</span><span class="params">(String address,</span></span></span><br><span class="line"><span class="function"><span class="params">String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">SingleServerConfig singleSerververConfig = config.useSingleServer();</span><br><span class="line">singleSerververConfig.setAddress(address).setPassword(password)</span><br><span class="line">.setConnectionMinimumIdleSize(<span class="number">1</span>).setConnectionPoolSize(<span class="number">64</span>);</span><br><span class="line">RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line"><span class="keyword">return</span> redissonClient;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="降级处理的实践"><a href="#降级处理的实践" class="headerlink" title="降级处理的实践"></a>降级处理的实践</h2><p>如上所述，如果Redis（或Redis集群）服务宕掉了，或者当网络抖动或Redis集群主从切换导致的各种异常导致Redis方式不可行，于是，需要做降级处理，所谓降级，就是异常情况下的备胎处理方式，这里我们先假设最容易处理的一种方式，如果系统中只有一主一从两个节点，那么我们可以简单处理，让双方错开一个定时间隔，分别使用netCat命令向对方进行端口检测，如果检测到对方节点中有正在运行的服务，则不启动甚至退出自己当前的服务。如果对方节点不在运行服务，则说明自己可以“获得锁”，便可运行服务，取代对方成为主节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置定时器，定时检测运行</span></span><br><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">runWithRedisLock(args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">runWithNetCat(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设两台机器服务地址+端口分别为[对方："192.168.11.20:8080", 本机："192.168.11.21:8080"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对方的服务地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADDRESS = <span class="string">"192.168.11.20"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对方的服务端口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PORT = <span class="string">"8080"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runWithNetCat</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">ILOG.info(<span class="string">"application is already running"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> hasRunner = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (netCat(ADDRESS, PORT)) &#123;</span><br><span class="line">hasRunner = <span class="keyword">true</span>;</span><br><span class="line">Application.stopApplication(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!hasRunner) &#123;</span><br><span class="line">Application.runApplication(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">netCat</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">NetUtil.netCat(host, port, <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">ILOG.warn(<span class="string">"net check error. "</span>, e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用服务端口检测方法的优缺点"><a href="#使用服务端口检测方法的优缺点" class="headerlink" title="使用服务端口检测方法的优缺点"></a>使用服务端口检测方法的优缺点</h3><p>这样的做法非常容易理解且操作简单，但也存在问题，譬如当两者不能互相ping通对方时，则两者可能都以为自己可以升级为主，造成脑裂现象。</p><h3 id="降级处理的更优实践"><a href="#降级处理的更优实践" class="headerlink" title="降级处理的更优实践"></a>降级处理的更优实践</h3><p>由上分析，我们得知依赖网络去简单做服务端口检测会存在不可靠，并且条件也限定在系统中只有一主一备两节点，如果存在多台节点服务，即一主多备时，我们还是要保证顺序一致性。基于这一点考虑，我们若使用数据库的实现方式，便可以满足实现上更简单、更可靠的降级要求。</p><h2 id="基于Spring-Boot的启动优化方案"><a href="#基于Spring-Boot的启动优化方案" class="headerlink" title="基于Spring Boot的启动优化方案"></a>基于Spring Boot的启动优化方案</h2><p>Spring Boot提供了 CommandLineRunner 接口，实现了 CommandLineRunner 接口的 Component 会在所有 Spring Beans 都初始化之后，SpringApplication.run() 之前执行，我们可以在这个方法里hold住服务的启动，在这里边作加锁成功的判断，从而实现一种只加载容器但不启动服务的“预加载”方案，这么做是因为，我们知道，spring应用启动的过程中，容器加载是较为耗时的，这种“待机式”的方案，可以让应用先准备好，当需要启动服务时便可更快速地进入服务状态。而除 CommandLineRunner 之外，使用ApplicationRunner也可以达到相同的目的，两者差别不大。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Zookeeper分布式锁原理图：<a href="https://juejin.im/post/5c01532ef265da61362232ed" target="_blank" rel="noopener">七张图彻底讲清楚ZooKeeper分布式锁的实现原理【石杉的架构笔记】</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Distributed </tag>
            
            <tag> HA </tag>
            
            <tag> Redis </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几张图总结几种I/O类型</title>
      <link href="/2018/11/20/Linux-IO-Types/"/>
      <url>/2018/11/20/Linux-IO-Types/</url>
      
        <content type="html"><![CDATA[<p>Unix/Linux支持的5种I/O类型：</p><ul><li>同步模型（synchronous IO） <ul><li>阻塞IO（bloking IO）</li><li>非阻塞IO（non-blocking IO）</li><li>多路复用IO（multiplexing IO）</li><li>信号驱动式IO（signal-driven IO）</li></ul></li><li>异步IO（asynchronous IO）</li></ul><h2 id="过程图解"><a href="#过程图解" class="headerlink" title="过程图解"></a>过程图解</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><img src="/images/post-IO-Types/20161010144954475.jpg" alt=""><br><br></p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p><img src="/images/post-IO-Types/20161010145820444.jpg" alt=""><br><br></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="/images/post-IO-Types/20161010150720979.jpg" alt=""><br><br></p><h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p><img src="/images/post-IO-Types/20161010153821072.jpg" alt=""><br><br></p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="/images/post-IO-Types/20161010153944432.jpg" alt=""></p><h2 id="怎么理解"><a href="#怎么理解" class="headerlink" title="怎么理解"></a>怎么理解</h2><p>I/O过程分两个阶段：</p><ol><li>数据从硬件（网卡、硬盘）拷贝到内核的内存空间。</li><li>数据从内核的内存空间拷贝到用户态的内存空间<br><br><br>为什么要分两个阶段？<br>（撇开零拷贝不说）前提是用户态程序（应用程序）不能直接跟硬件打交道，而能与硬件打交道的就只能是内核，用户态程序要想从硬件获得数据，必须通知内核我要获得硬件中的数据，此过程称为系统调用，为第一阶段。<br>于是，自然就有了第二阶段，数据从内核内存空间到用户态内存空间。（对用户态来讲，此过程才是I/O发生的地方）</li></ol><h2 id="概括每种I-O类型的过程"><a href="#概括每种I-O类型的过程" class="headerlink" title="概括每种I/O类型的过程"></a>概括每种I/O类型的过程</h2><p>OK，有了两阶段的概念后，可以简单来理解并总结每种I/O类型的过程:<br><img src="/images/post-IO-Types/20181120062926.jpg" alt=""></p><p>一图胜千言：<br><img src="/images/post-IO-Types/20181121075237.jpg" alt=""></p><h2 id="浅谈零拷贝"><a href="#浅谈零拷贝" class="headerlink" title="浅谈零拷贝"></a>浅谈零拷贝</h2><p>既然提到零拷贝，那就粗浅地说明一下：<br>零拷贝是指，减免了数据在内核空间和用户空间来回拷贝。<br><br><br>用户态程序调用mmap()，磁盘上的数据会通过DMA（直接内存存取，direct memory access）被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这种所谓的共享，方式就是mmap（内存映射，memory map），这样就不需要把内核缓冲区的内容往用户空间拷贝。用户态程序再调用write()，操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。<br><br><br>好吧，一图胜千言：<br><img src="/images/post-IO-Types/20181120064306.jpg" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《UNIX网络编程》</p><p><a href="https://www.jianshu.com/p/fad3339e3448" target="_blank" rel="noopener">浅析Linux中的零拷贝技术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> I/O </tag>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ相关总结</title>
      <link href="/2018/11/18/RocketMQ-Summary/"/>
      <url>/2018/11/18/RocketMQ-Summary/</url>
      
        <content type="html"><![CDATA[<p>总结RocketMQ相关知识点，便于回顾记忆…</p><h2 id="RocketMQ相关网址"><a href="#RocketMQ相关网址" class="headerlink" title="RocketMQ相关网址"></a>RocketMQ相关网址</h2><p>官网：<a href="https://rocketmq.incubator.apache.org/" target="_blank" rel="noopener">https://rocketmq.incubator.apache.org/</a></p><p>源码：<a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a></p><h2 id="RocketMQ总体特点"><a href="#RocketMQ总体特点" class="headerlink" title="RocketMQ总体特点"></a>RocketMQ总体特点</h2><ol><li><p>能够保证严格的消息顺序</p></li><li><p>提供丰富的消息拉取模式</p></li><li><p>高效的订阅者水平扩展能力</p></li><li><p>实时的消息订阅机制</p></li><li><p>亿级消息堆积能力</p></li></ol><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>主要以commitLog为消息存储的数据结构。<br><img src="/images/post-RocketMQ-Summary/20160627161734720.jpg" alt=""></p><p><img src="/images/post-RocketMQ-Summary/20160627161750955.jpg" alt=""></p><p>（1）所有数据单独储存到commit Log ，完全顺序写，随机读</p><p>（2）对最终用户展现的队列实际只储存消息在Commit Log 的位置信息，并且串行方式刷盘</p><p>（3）按照MessageId查询消息</p><p><img src="/images/post-RocketMQ-Summary/20160627161909644.jpg" alt=""></p><p>（4）根据查询的key的hashcode%slotNum得到具体的槽位置</p><p><img src="/images/post-RocketMQ-Summary/20160627162003737.jpg" alt=""></p><p>（5）根据slotValue（slot对应位置的值）查找到索引项列表的最后一项</p><p>（6）遍历索引项列表返回查询时间范围内的结果集</p><h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p><img src="/images/post-RocketMQ-Summary/20181118164510.jpg" alt=""><br>作为一款纯 Java 语言开发的消息引擎，RocketMQ 自主研发的存储组件，依赖 Page Cache 进行加速和堆积，意味着它的性能会受到 JVM、 GC、内核、Linux 内存管理机制、文件 IO 等因素的影响。Rocketmq中的所有消息都是持久化到硬盘的，但会使用系统PageCache加速访问，消息的落地方式是先写PageCache后刷盘，可以保证内存与磁盘都有一份数据，访问时，可以直接从内存读取。如图所示，一条消息从客户端发送出，到最终落盘持久化，每个环节都有产生延迟的风险。</p><blockquote><p>《不一样的技术创新-阿里巴巴2016双十一背后的技术》一书中提到，有线上数据显示，RocketMQ 写消息链路存在偶发的高达数秒的延迟</p></blockquote><ul><li><p><strong>同步刷盘</strong><br>同步刷盘是指，broker在收到每个消息后，都是先要保存到硬盘上，然后再给producer确认。</p></li><li><p><strong>异步刷盘</strong><br>异步刷盘就是先回复确认，然后批量保存到硬盘上。异步刷盘有更好的性能，当然也有更大的丢失消息的风险。</p></li></ul><h2 id="角色关系图"><a href="#角色关系图" class="headerlink" title="角色关系图"></a>角色关系图</h2><p><img src="/images/post-RocketMQ-Summary/20181118155237.jpg" alt=""></p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/post-RocketMQ-Summary/20160629175853107.jpg" alt=""></p><h3 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h3><p>所有的集群都具有水平扩展能力，无单点障碍。<br><br></p><ul><li>NameServer以轻量级的方式提供服务发现和路由功能，每个NameServer存有全量的路由信息，提供对等的读写服务，是一个几乎无状态节点，可集群部署，节点之间无任何信息同步，支持快速扩缩容。<br><br></li><li>Broker为实际的消息队列服务器(MQ Server)，在整体架构中，可以看作是Producer与Comsumer之间的驳脚者，消息通过它从Producer接收，并存储，后转发给Consumer。以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型，具备多副本容错机制（2副本或3副本）、强大的削峰填谷以及上亿级消息堆积能力，同时可严格保证消息的有序性。<blockquote><p>除此之外，Broker还提供了同城异地容灾能力，丰富的Metrics统计以及告警机制。这些都是传统消息系统无法比拟的。</p></blockquote></li><li>Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。</li><li>Consumer也由用户部署，支持PUSH和PULL两种消费模式（推模式的实现也是用的拉方式），支持集群消费和广播消息，提供实时的消息订阅机制，满足大多数消费场景。</li></ul><h2 id="RocketMQ亮点-支持多种消费模式"><a href="#RocketMQ亮点-支持多种消费模式" class="headerlink" title="RocketMQ亮点-支持多种消费模式"></a>RocketMQ亮点-支持多种消费模式</h2><p>RocketMQ最初还未正式称为RocketMQ，一开始v1.0还是叫metaQ，经历了3代的重要演进，v3.0开始改名RocketMQ，其重要改进包括消息获取模式。<br><br></p><ol><li>第一代，推模式，数据存储采用关系型数据库。在这种模式下，消息具有很低的延迟特性，并且很容易支持分布式事务。尤其在阿里淘宝这种高频交易场景中，具有非常广泛地应用。典型代表包括Notify、Napoli。</li><li>第二代，拉模式，自研的专有消息存储。在日志处理方面能够媲美Kafka的吞吐性能，但考虑到淘宝的应用场景，尤其是其交易链路的高可靠需求，消息引擎并没有一味的追求吞吐，而是将稳定可靠放在首位。因为采用了长连接拉模式，在消息的实时方面丝毫不逊推模式。典型代表MetaQ。</li><li>第三代，以拉模式为主，兼有推模式的高性能、低延迟消息引擎RocketMQ，在二代功能特性的基础上，为电商金融领域添加了可靠重试、基于文件存储的分布式事务等特性，并做了大量优化。从2012年开始，经历了历次双11核心交易链路检验。目前已经捐赠给Apache基金会。</li></ol><p>不难看出，RocketMQ其实是伴随着阿里巴巴整个生态的成长，逐渐衍生出来的高性能，高可用，兼具高吞吐量和低延迟、能够同时满足电商领域和金融领域的极尽苛刻场景的消息中间件。</p><h2 id="Broker部署方式"><a href="#Broker部署方式" class="headerlink" title="Broker部署方式"></a>Broker部署方式</h2><h3 id="单Master"><a href="#单Master" class="headerlink" title="单Master"></a>单Master</h3><blockquote><p>这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。</p></blockquote><h3 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h3><p>多台Broker，全是Master</p><blockquote><p>优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由于RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。<br>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p></blockquote><h3 id="HA方案：多Master-Slave对模式"><a href="#HA方案：多Master-Slave对模式" class="headerlink" title="HA方案：多Master/Slave对模式"></a>HA方案：多Master/Slave对模式</h3><p>每个 Master 配对一个 Slave，有多对Master-Slave。</p><h4 id="Master-Slave复制方式"><a href="#Master-Slave复制方式" class="headerlink" title="Master/Slave复制方式"></a>Master/Slave复制方式</h4><ul><li><p>同步双写<br>写入消息时，master先写入，之后复制到slave，确认slave也存储了消息后才向producer答复返回成功。</p><blockquote><p>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高<br>缺点：性能比异步复制模式略低，大约低10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p></blockquote></li><li><p>异步复制<br>先答复producer，再去向salve复制。</p><blockquote><p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。<br>缺点：Master宕机，磁盘损坏情况，会丢失少量消息。</p></blockquote></li></ul><p>通过同步复制技术可以完全避免单点，同步复制势必会影响性能，适合应用于消息可靠性要求极高的场合。RocketMQ从3.0版本开始支持同步双写。</p><h2 id="两种消息消费的交互方式的区别"><a href="#两种消息消费的交互方式的区别" class="headerlink" title="两种消息消费的交互方式的区别"></a>两种消息消费的交互方式的区别</h2><p>留意源码可以得知：<br>consumer被分为2类：MQPullConsumer和MQPushConsumer，本质都是拉模式（pull），即consumer轮询从broker拉取消息。<br>区别在于：</p><ul><li><p>push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对客户端而言，感觉消息是被推送（push）过来的。</p></li><li><p>pull方式里，取消息的过程，RocketMQ交给了用户自己实现，首先通过待消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Java缓存  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; offseTable = <span class="keyword">new</span> HashMap&lt;MessageQueue, Long&gt;();  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String nameServAndAddr = <span class="string">"172.16.235.77:9876;172.16.235.78:9876"</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumerGroupName =<span class="string">"ConsumerGroupName"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String consumber =<span class="string">"Consumber"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 主动拉取方式消费 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MQClientException </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;  </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 一个应用创建一个Consumer，由应用来维护此对象，可以设置为全局对象或者单例&lt;br&gt; </span></span><br><span class="line"><span class="comment">         * 注意：ConsumerGroupName需要由应用来保证唯一 ,最好使用服务的包名区分同一服务,一类Consumer集合的名称， </span></span><br><span class="line"><span class="comment">         * 这类Consumer通常消费一类消息，且消费逻辑一致 </span></span><br><span class="line"><span class="comment">         * PullConsumer：Consumer的一种，应用通常主动调用Consumer的拉取消息方法从Broker拉消息，主动权由应用控制 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        DefaultMQPullConsumer consumer = <span class="keyword">new</span> DefaultMQPullConsumer(consumerGroupName);  </span><br><span class="line">        <span class="comment">// //nameserver服务  </span></span><br><span class="line">        consumer.setNamesrvAddr(nameServAndAddr);  </span><br><span class="line">        consumer.setInstanceName(consumber);  </span><br><span class="line">        consumer.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 拉取订阅主题的队列，默认队列大小是4  </span></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">"TopicTest1"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Consume from the queue: "</span> + mq);  </span><br><span class="line">            SINGLE_MQ: <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    PullResult pullResult = </span><br><span class="line">                consumer.pullBlockIfNotFound(</span><br><span class="line">                        mq, <span class="keyword">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);  </span><br><span class="line">                    List&lt;MessageExt&gt; list = pullResult.getMsgFoundList();  </span><br><span class="line">                    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &lt; <span class="number">100</span>) &#123;  </span><br><span class="line">                        <span class="keyword">for</span> (MessageExt msg : list) &#123;  </span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(msg.getBody()));  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    System.out.println(pullResult.getNextBeginOffset());  </span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());  </span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:  </span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;  </span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        <span class="keyword">default</span>:  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        consumer.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="keyword">long</span> offset)</span> </span>&#123;  </span><br><span class="line">        offseTable.put(mq, offset);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> </span>&#123;  </span><br><span class="line">        Long offset = offseTable.get(mq);  </span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(offset);  </span><br><span class="line">            <span class="keyword">return</span> offset;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RocketMQ使用长轮询Pull方式，可保证消息非常实时，消息实时性不低于Push</p></blockquote><p>长轮询Pull：<br>建立长连接，每隔一定时间，客户端向服务端发起请求询问数据，如有则返回数据，如无则返回空，然后关闭请求。<br>长轮询与普通轮询的不同之处在于，哪怕服务端此时没有数据，连接还是保持的，等到有数据时可以立即返回（也就模拟push），或者超时返回。<br>长轮询好处在于可以减少无效请求，保证消息实时性获取，又不会造成积压。</p><blockquote><p>推拉模式的具体选取视乎实际情况而定，在一些离线大批量数据处理系统中，消息获取的需求强调的更多是吞吐量，而非低延迟，此时拉模式可能更优。</p></blockquote><h2 id="RocketMQ-高可用保障"><a href="#RocketMQ-高可用保障" class="headerlink" title="RocketMQ 高可用保障"></a>RocketMQ 高可用保障</h2><p>通过可用性计算公式可以看出，要提升系统的可用性，需要在保障系统健壮性以延长平均无故障时间的基础上，进一步加强系统的故障自动恢复能力以缩短平均故障修复时间。 RocketMQ 高可用架构设计并实现了 Controller 组件，按照单主状态、异步复制状态、半同步状态以及最终的同步复制状态的有限状态机进行转换。在最终的同步复制状态下，Master 和 Slave 任一节点故障时，其它节点能够在秒级时间内切换到单主状态继续提供服务。相比于之前人工介入重启来恢复服务，RokcetMQ 高可用架构赋予了系统故障自动恢复的能力，能极大缩短平均故障恢复时间，提升系统的可用性。</p><p>下图描述了 RocketMQ 高可用架构中有限状态机的转换：</p><p><img src="/images/post-RocketMQ-Summary/20181118180808.jpg" alt=""></p><p>1） 第一个节点启动后，Controller 控制状态机切换为单主状态，通知启动节点以 Master 角色提供服务。<br>2） 第二个节点启动后， Controller 控制状态机切换成异步复制状态。Master 通过异步方式向 Slave 复制数据。<br>3） 当 Slave 的数据即将赶上 Master，Controller 控制状态机切换成半同步状态，此时命中 Master 的写请求会被 Hold 住，直到 Master以异步方式向 Slave 复制了所有差异的数据。<br>4） 当半同步状态下 Slave 的数据完全赶上 Master 时，Controller控制状态机切换成同步复制模式，Mater 开始以同步方式向 Slave 复制数据。该状态下任一节点出现故障，其它节点能够在秒级内切换到单主状态继续提供服务。<br>Controller 组件控制 RocketMQ 按照单主状态，异步复制状态，半同步状态，同步复制状态的顺序进行状态机切换。中间状态的停留时间与主备之间的数据差异以及网络带宽有关，但最终都会稳定在同步复制状态下。</p><h2 id="如何保证消息有序消费？"><a href="#如何保证消息有序消费？" class="headerlink" title="如何保证消息有序消费？"></a>如何保证消息有序消费？</h2><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照这个顺序消费才有意义。但同时订单之间又是可以并行消费的。</p><p>假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：<br><img src="/images/post-RocketMQ-Summary/20160628162759326.jpg" alt=""></p><p>M1发送到S1后，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端后，通知S2，然后S2再将M2发送到消费端。</p><p>这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到，也就不能保证M1被先消费，那么就需要在MQ Server集群维护消息的顺序。那么如何解决？一种简单的方式就是将M1、M2发送到同一个Server上：<br><img src="/images/post-RocketMQ-Summary/20160628163033073.jpg" alt=""></p><p>这样可以保证M1先于M2到达MQServer（客户端等待M1成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。</p><p>这个模型，理论上可以保证消息的顺序，但在实际运用中你应该会遇到下面的问题：<br><img src="/images/post-RocketMQ-Summary/20160628163128871.jpg" alt=""></p><p>只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就先被消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费。如何解决这个问题？将M1和M2发往同一个消费者即可，且发送M1后，需要消费端响应成功后才能发送M2。</p><p>但又会引入另外一个问题，如果发送M1后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。</p><p><img src="/images/post-RocketMQ-Summary/20160628163222107.jpg" alt=""></p><p>这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达，另外一种情况是消费端1已经响应，但是Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就是我们后面要说的第二个问题，消息重复问题。</p><p>回过头来看消息顺序问题，严格的顺序消息非常容易理解，而且处理问题也比较容易，要实现严格的顺序消息，简单且可行的办法就是：</p><blockquote><p>保证生产者 - MQServer - 消费者是一对一对一的关系</p></blockquote><p>但是这样设计，并行度就成为了消息系统的瓶颈（吞吐量不够），也会导致更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</p><p>但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？</p><p>有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决它们身上，实际上是浪费的，效率低下的。从这个角度来看消息的顺序问题，我们可以得出两个结论：</p><blockquote><ol><li>不关注乱序的应用实际大量存在 </li><li>队列无序并不意味着消息无序</li></ol></blockquote><p>最后我们从源码角度分析RocketMQ怎么实现发送顺序消息。</p><p>一般消息是通过轮询所有队列来发送的（负载均衡策略），顺序消息可以根据业务，比如说订单号相同的消息发送到同一个队列。下面的示例中，OrderId相同的消息，会发送到同一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash</span></span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        Integer id = (Integer) arg;</span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, orderId);</span><br></pre></td></tr></table></figure><p>在获取到路由信息以后，会根据MessageQueueSelector实现的算法来选择一个队列，同一个OrderId获取到的队列是同一个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">send</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 获取topic路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据我们的算法，选择一个发送队列</span></span><br><span class="line">        <span class="comment">// 这里的arg = orderId</span></span><br><span class="line">        mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">        <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息重复–如何保证幂等性"><a href="#消息重复–如何保证幂等性" class="headerlink" title="消息重复–如何保证幂等性"></a>消息重复–如何保证幂等性</h2><p>上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</p><p>造成消息的重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是不解决，转而绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><blockquote><ol><li>消费端处理消息的业务逻辑保持幂等性 </li><li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li></ol></blockquote><p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p><p>我们可以看到第1条的解决方式，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率不一定大，且由消息系统实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p><p>RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</p><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。</p><h3 id="旧版事务消息："><a href="#旧版事务消息：" class="headerlink" title="旧版事务消息："></a>旧版事务消息：</h3><p>参考 <a href="https://blog.csdn.net/asdf08442a/article/details/54882769" target="_blank" rel="noopener">RocketMQ总结整理</a>-事务消息</p><h3 id="RocketMQ-4-3-新版事务消息："><a href="#RocketMQ-4-3-新版事务消息：" class="headerlink" title="RocketMQ 4.3 新版事务消息："></a>RocketMQ 4.3 新版事务消息：</h3><p><img src="/images/post-RocketMQ-Summary/20181118221948.jpg" alt=""></p><p>这张图说明了事务消息的大致方案，分为两个逻辑：正常事务消息的发送及提交、事务消息的补偿流程。</p><ul><li><p>事务消息发送及提交：</p><p>  发送消息（half消息）<br>  服务端响应消息写入结果<br>  根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）<br>  根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p></li><li><p>补偿流程：</p><p>  对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”<br>  Producer收到回查消息，检查回查消息对应的本地事务的状态<br>  根据本地事务状态，重新Commit或者Rollback<br>  补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p></li></ul><h3 id="新版事务消息的设计原理"><a href="#新版事务消息的设计原理" class="headerlink" title="新版事务消息的设计原理"></a>新版事务消息的设计原理</h3><p>RocketMQ事务消息的提交方式是2PC，一阶段消息可以理解为Prepared Message或者Pending Message，实际上就是说，消息要先提交并落地到Broker，但不能是对用户可见的。<br><br><br>如何做到写入了消息但是对用户不可见?——写入消息数据，但是不创建对应的消息的索引信息。<br><img src="/images/post-RocketMQ-Summary/20181119061401.jpg" alt=""><br>RocketMQ消息在服务端的存储结构如上，每条消息都会有对应的索引信息，Consumer通过索引读取消息。<br>那么实现一阶段写入的消息不被用户消费（需要在Commit后才能消费），只需要写入Storage Queue，但是不构建Index Queue即可。</p><p>RocketMQ中具体实现策略是：写入的如果是事务消息，则对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中。<br>代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">            String.valueOf(msgInner.getQueueId()));</span><br><span class="line">        msgInner.setSysFlag(</span><br><span class="line">            MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), </span><br><span class="line">            MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">        msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">        msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">        <span class="keyword">return</span> msgInner;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>替换属性后这条消息被写入到TransactionalMessageUtil.buildHalfTopic()的Queue 0中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalMessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVETAG = <span class="string">"d"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildHalfTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MixAll.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在完成Storage Queue的写入后，在appendCallback中，普通消息会去构建消息索引，<strong>而如果发现是事务消息，则跳过了创建索引的逻辑。</strong></p><blockquote><p>RocketMQ将事务消息一阶段发送的消息称为Half消息，我们可以理解为，这条消息相对普通消息的操作只做了一半（只落地而未索引），不算是一条完整的普通消息</p></blockquote><p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。</p><p>先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。</p><p>但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。</p><p>RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息是否状态已经确定（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。</p><p>引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。</p><p>Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</p><p>Half消息的索引构建</p><p>在执行二阶段的Commit操作时，需要构建出Half消息的索引。</p><p>一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。</p><p>所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p><p>如何处理二阶段失败的消息</p><p>如果二阶段失败了，比如在Commit操作时出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。</p><p>RocketMQ采用了一种补偿机制，称为“回查”。</p><p>Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。</p><p>Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p><p>值得注意的一点是具体实现中，在回查前，系统会执行putBackHalfMsgQueue操作，即将Half消息重新写一遍到Half消息的Queue中。这么做其实是为了能有效的推进上面的CheckPoint。</p><h3 id="新版事务消息设计总结"><a href="#新版事务消息设计总结" class="headerlink" title="新版事务消息设计总结"></a>新版事务消息设计总结</h3><p><img src="/images/post-RocketMQ-Summary/20181119063901.jpg" alt=""></p><ul><li>通过写Half消息的方式来实现一阶段消息对用户不可见</li><li>通过Op消息来标记事务消息的状态</li><li>通过读取Half消息来生成一条新的Normal消息来完成二阶段Commit之后消息对Consumer可见</li><li>通过Op消息来执行回查</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><p>分布式消息引擎 《不一样的技术创新-阿里巴巴2016双十一背后的技术》</p></li><li><p><a href="https://www.jianshu.com/p/66edd4f99e3c" target="_blank" rel="noopener">RocketMq知识点理解</a></p></li><li><p><a href="https://blog.csdn.net/asdf08442a/article/details/54882769" target="_blank" rel="noopener">RocketMQ总结整理</a></p></li><li><p><a href="https://blog.csdn.net/qq_42564846/article/details/81476291" target="_blank" rel="noopener">RocketMQ事务消息实现分析</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 异步 </tag>
            
            <tag> 削峰 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>总结ThreadLocal</title>
      <link href="/2018/11/05/ThreadLocal-Summary/"/>
      <url>/2018/11/05/ThreadLocal-Summary/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLoacal简介"><a href="#ThreadLoacal简介" class="headerlink" title="ThreadLoacal简介"></a>ThreadLoacal简介</h2><p>ThreadLocal类是修饰变量的，重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了。<br><br><br>根据变量的作用域，可以将变量分为全局变量，局部变量。简单的说，类里面定义的变量是全局变量，函数里面定义的变量是局部变量。<br>还有一种作用域是线程作用域，线程一般是跨越几个函数的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是ThreadLocal变量。<br><br><br>ThreadLocal变量，不同于它们的普通对应物，因为访问某个变量（通过其get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<strong>ThreadLocal为每个使用该变量的线程分配一个独立的变量副本。所以每一个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。</strong>所以我们说，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。</p><h2 id="ThreadLocal的用处"><a href="#ThreadLocal的用处" class="headerlink" title="ThreadLocal的用处"></a>ThreadLocal的用处</h2><p>Web开发中常见到的一个问题：多用户session问题。<br>假设有多个用户需要获取用户信息，一个线程对应一个用户。在mybatis中，session用于操作数据库，那么设置、获取操作分别是session.set()、session.get()，如何保证每个线程都能正确操作达到想要的结果呢？</p><p>假如我们要设置一个变量，作为各个线程共享的变量，来存储session信息，那么当我们需要让每个线程独立地设置session信息而不被其它线程打扰，要怎么做呢？很容易想到了加锁，譬如synchronized，互斥同步锁synchronized自JDK1.5经过优化后，不会很消耗资源了，但当成千上万个操作来临之时，扛高并发能力不说，数据返回延迟带来的用户体验变差又如何解决？</p><p>那么，就上文提出的问题，引申出来，像mybatis，hibernate一类的框架是如何解决这个session问题的呢？</p><p>来看一下，mybatis的SqlSessionManager类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionManager</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span>, <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;SqlSession&gt; localSqlSession = <span class="keyword">new</span> ThreadLocal&lt;SqlSession&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SqlSessionManager</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) Proxy.newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;SqlSession.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startManagedSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localSqlSession.set(openSession());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startManagedSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localSqlSession.set(openSession(autoCommit));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startManagedSession</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localSqlSession.set(openSession(connection));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SqlSession sqlSession = localSqlSession.get();</span><br><span class="line">    <span class="keyword">if</span> (sqlSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SqlSessionException(<span class="string">"Error:  Cannot get connection.  No managed session is started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSession.getConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>留意到，mybatis里的localSqlSession就是用的ThreadLocal变量来实现。</p><p>从内存模型出发看ThreadLocal：<br><img src="/images/post-ThreadLocal-Summary/20181111170001.jpg" alt=""></p><p>我们知道，在虚拟机中，堆内存就是用于存储共享数据，也就是这里所说的主内存。</p><p>每个线程将会在堆内存中开辟一块空间叫做线程的工作内存，附带一块缓存区用于存储共享数据副本。那么，共享数据在堆内存当中，线程通信就是通过主内存为中介，线程在本地内存读并且操作完共享变量操作完毕以后，把值写入主内存。</p><ol><li>ThreadLocal被称为线程局部变量，说白了就是线程工作内存的一小块内存，用于存储数据。</li><li>那么，ThreadLocal.set()、ThreadLocal.get()方法，就相当于把数据存储于线程本地，取也是在本地内存读取。就不会像synchronized需要频繁的修改主内存的数据，再把数据复制到工作内存，也大大提高访问效率。</li></ol><p>那么，我们再来回答上面引出的问题，mybatis为什么要用ThreadLocal来存储session？</p><p> 首先，因为线程间的数据交互是通过工作内存与主存的频繁读写完成通信，然而存储于线程本地内存，提高访问效率，避免线程阻塞造成cpu吞吐率下降。再者，在多线程中，每一个线程都各自维护session，轻易完成对线程独享资源的操作。</p><h2 id="理解ThreadLocal的关键源码"><a href="#理解ThreadLocal的关键源码" class="headerlink" title="理解ThreadLocal的关键源码"></a>理解ThreadLocal的关键源码</h2><p>首先，要理解ThreadLocal的数据结构，我们可以看它的set/get方法：<br>ThreadLocal.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Thread.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><ol><li>ThreadLocalMap作为ThreadLocal的静态内部类，用于存储多个ThreadLocal对象</li><li>ThreadLocal对象作为ThreadLocalMap的key来存储，我们set进去的独享数据作为value存储</li><li>留意到它里边调到的getMap(Thread)方法，得知ThreadLocalMap的获取跟当前Thread有关，仔细看threadLocals其实就是当前线程的一个ThreadLocalMap变量。也就是说，一个线程对应一个ThreadLocalMap，get()就是当前程获取自己的ThreadLocalMap。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 线程根据使用那一小块的线程本地内存，以ThreadLocal对象作为key，去获取存储于ThreadLocalMap中的值。</p><h2 id="ThreadLocal内存泄露"><a href="#ThreadLocal内存泄露" class="headerlink" title="ThreadLocal内存泄露"></a>ThreadLocal内存泄露</h2><h3 id="引用关系图"><a href="#引用关系图" class="headerlink" title="引用关系图"></a>引用关系图</h3><p> 先引用一张经典的引用关系图来说明当前线程(currentThread)以及threadLocalMap、key、threadLocal实例几个之间的引用关系：<br><img src="/images/post-ThreadLocal-Summary/20181111174333.jpg" alt=""></p><p>利用这图来回顾总结一下ThreadLocal的实现：<br>每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</p><p>也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><p>我们可以理解到，每个线程都会创建一块工作内存，每个线程都有一个ThreadLocalMap，而ThreadLocalMap可以有多个key，也就是说可以存储多个ThreadLocal。那么假设，开启1万个线程，每个线程创建1万个ThreadLocal，也就是每个线程维护1万个ThreadLocal小内存空间！<br>那么，当线程执行结束以后，如果一个ThreadLocal没有外部强引用来引用它而是用弱引用来引用，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><h4 id="Key使用什么引用才好？"><a href="#Key使用什么引用才好？" class="headerlink" title="Key使用什么引用才好？"></a>Key使用什么引用才好？</h4><p>如上，key对ThreadLocal使用弱引用会发生内存泄露。<br>那么，如果使用强使用，问题是否就得以解决？<br><br><br>若 key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br><br><br>那么如果 key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的引用是弱引用，即使没有手动删除，ThreadLocal也会被回收。至于value，则在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br><br><br>所以比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，而对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。<br><br><br>因此，<strong>ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</strong><br><br></p><h3 id="ThreadLocal防内存泄露最佳实践"><a href="#ThreadLocal防内存泄露最佳实践" class="headerlink" title="ThreadLocal防内存泄露最佳实践"></a>ThreadLocal防内存泄露最佳实践</h3><p>综上，我们可以理解ThreadLocal为避免内存泄露的设计大致上是：</p><ol><li>JVM利用ThreadLocalMap的Key为弱引用，来避免ThreadLocal内存泄露。</li><li>由于Key设置为弱引用，那么，当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。<br><br><br>所以，每次使用完ThreadLocal，都调用它的remove()方法，清除数据，则可以达到回收弱引用的结果，这是最佳的使用实践。否则，在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.cnblogs.com/qiuyong/p/7091689.html" target="_blank" rel="noopener">《并发编程（四）：ThreadLocal从源码分析总结到内存泄漏》</a><br><a href="http://www.importnew.com/22039.html" target="_blank" rel="noopener">《深入分析 ThreadLocal 内存泄漏问题》</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>整理Volatile</title>
      <link href="/2018/11/03/Volatile-Summary/"/>
      <url>/2018/11/03/Volatile-Summary/</url>
      
        <content type="html"><![CDATA[<p>整理volatile相关，便于回顾记忆…</p><h2 id="Volatile简介"><a href="#Volatile简介" class="headerlink" title="Volatile简介"></a>Volatile简介</h2><p>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”，但不像synchronized一样保证原子性。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p><h2 id="Volatile的特性"><a href="#Volatile的特性" class="headerlink" title="Volatile的特性"></a>Volatile的特性</h2><ol><li>volatile可见性；对一个volatile的读，总可以看到对这个变量最近一次的写；</li><li>volatile原子性；volatile对单个读/写具有原子性（32位Long、Double），但是复合操作除外，例如i++;</li><li>JVM底层采用“内存屏障”来实现volatile语义，禁止重排序以保证有序性</li></ol><p>理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。下面通过具体的示例来说明，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 使用volatile声明64位的long型变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        vl = l; <span class="comment">// 单个volatile变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        vl++; <span class="comment">// 复合（多个）volatile变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">// 单个volatile变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的3个方法，这个程序在语义上和下面程序等价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> vl = <span class="number">0L</span>; <span class="comment">// 64位的long型普通变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">// 对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span> <span class="params">()</span> </span>&#123; <span class="comment">// 普通方法调用</span></span><br><span class="line">        <span class="keyword">long</span> temp = get(); <span class="comment">// 调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">// 普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">// 调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// 对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。<br><br><br>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<br><br><br>锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</p><h2 id="Volataile的内存语义及其实现"><a href="#Volataile的内存语义及其实现" class="headerlink" title="Volataile的内存语义及其实现"></a>Volataile的内存语义及其实现</h2><p>Java语言规范对volatile的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。</span><br></pre></td></tr></table></figure></p><p>通俗点讲就是说一个变量如果用volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。</p><p>在了解volatile实现原理之前，我们先来看下与其实现原理相关的CPU术语与说明。下表是CPU术语的定义</p><p><img src="/images/post-Volatile-Summary/20181104004150.jpg" alt=""></p><p>Volatile是如何来保证可见性的呢？让我们在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时，CPU会做什么事情。</p><p>Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = new Singleton(); // instance是volatile变量</span><br></pre></td></tr></table></figure></p><p>转变成汇编代码，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);</span><br></pre></td></tr></table></figure></p><p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，Lock前缀的指令在多核处理器下会引发了两件事情。</p><p>1） 将当前处理器缓存行的数据写回到系统内存。<br>2） 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br><br><br>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。<br><br><br>下面来具体讲解volatile的两条实现原则。</p><ol><li>Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存[2]。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。在8.1.4节有详细说明锁定操作对处理器缓存的影响，对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel 64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6 family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</li></ol><p><img src="/images/post-Volatile-Summary/‎2018‎‎11‎‎4‎‏104116.jpg" alt=""></p><h2 id="Volatile写-读建立的happens-before关系"><a href="#Volatile写-读建立的happens-before关系" class="headerlink" title="Volatile写-读建立的happens-before关系"></a>Volatile写-读建立的happens-before关系</h2><p>从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。<br><br><br>从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">int</span> i = a; <span class="comment">// 4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before规则，这个过程建立的happens-before关系可以分为3类：<br>1) 根据程序次序规则，1 happens-before 2;3 happens-before 4。<br>2) 根据volatile规则，2 happens-before 3。<br>3) 根据happens-before的传递性规则，1 happens-before 4。<br><br><br><img src="/images/post-Volatile-Summary/20181104185650.jpg" alt=""><br>在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens-before保证。<br>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p><h2 id="限制重排序"><a href="#限制重排序" class="headerlink" title="限制重排序"></a>限制重排序</h2><p>重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型.以下是JMM针对编译器制定的volatile重排序规则表：<br><img src="/images/post-Volatile-Summary/20181105003929.jpg" alt=""><br>举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。<br><br><br>从表中可以看出：</p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保<br>volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保<br>volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。<br><br><br>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图:<br><img src="/images/post-Volatile-Summary/20181105004613.jpg" alt=""><br>图中的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。<br>这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：在每个volatile写的后面，或者在每个volatile读的前面插入一个StoreLoad屏障。从整体执行效率的角度考虑，JMM最终选择了在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里可以看到JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。<br><br><br>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图:<br><img src="/images/post-Volatile-Summary/20181105004941.jpg" alt=""><br>图中的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。<br>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面通过具体的示例代码进行说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = v1; <span class="comment">// 第一个volatile读</span></span><br><span class="line">        <span class="keyword">int</span> j = v2; <span class="comment">// 第二个volatile读</span></span><br><span class="line">        a = i + j; <span class="comment">// 普通写</span></span><br><span class="line">        v1 = i + <span class="number">1</span>; <span class="comment">// 第一个volatile写</span></span><br><span class="line">        v2 = j * <span class="number">2</span>; <span class="comment">// 第二个 volatile写</span></span><br><span class="line">    &#125;</span><br><span class="line">    …<span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化。<br><img src="/images/post-Volatile-Summary/20181105005251.jpg" alt=""><br>注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。此时编译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插入一个StoreLoad屏障。<br>上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为例，图3-21<br>中除最后的StoreLoad屏障外，其他的屏障都会被省略。<br>前面保守策略下的volatile读和写，在X86处理器平台可以优化成如下图所示。<br>前文提到过，X86处理器仅会对写-读操作做重排序。X86不会对读-读、读-写和写-写操作做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。在X86中，JMM仅需在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存语义。这意味着在X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）。<br><img src="/images/post-Volatile-Summary/20181105005442.jpg" alt=""></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>《Java并发编程的艺术》–方腾飞</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>整理Synchronized</title>
      <link href="/2018/11/03/Synchronized-Summary/"/>
      <url>/2018/11/03/Synchronized-Summary/</url>
      
        <content type="html"><![CDATA[<p>整理volatile相关，便于回顾记忆…</p><h2 id="Synchronized简介"><a href="#Synchronized简介" class="headerlink" title="Synchronized简介"></a>Synchronized简介</h2><p>Synchronized一直是Java多线程并发编程中用作同步的元老级角色，很多人对它的概念都是一个重量级锁，但在JDK 1.6，对synchronized进行了各种优化，为了减少获得锁和释放锁带来的性能消耗而引入了偏向锁和轻量级锁，和锁的存储结构和升级过程。<br><br><br>Synchronized实现同步的基础在于Java中的每一个对象都可以作为，所以本质上synchronized就是一把对象锁。<br><br><br>Synchronized可作用于类，静态方法，普通方法，及代码块，具体表现为以下3种形式：</p><ul><li>对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br><br><br>那么锁到底存在哪里呢？锁里面会存储什么信息呢？</p><h2 id="同步的原理"><a href="#同步的原理" class="headerlink" title="同步的原理"></a>同步的原理</h2><h3 id="管程-Monitor-对象"><a href="#管程-Monitor-对象" class="headerlink" title="管程(Monitor)对象"></a>管程(Monitor)对象</h3><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现，无论是显式同步，还是隐式同步都如此。</p><ul><li>显式同步是指有明确的monitorenter和monitorexit指令，也就是synchronized同步代码块的场景</li><li>隐式同步则是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED 标志来隐式实现，也就是指方法同步的场景</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println( <span class="string">"test1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        System.out.println( <span class="string">"test2"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/post-Synchronized-Summary/20181103195754.jpg" alt=""></p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充，一般而言，synchronized使用的锁对象是存储在Java对象头里的。如果对象是非数组类型，则用2字宽存储对象头，如果对象是数组则会分配3个字宽，多出来的1个字记录的是数组长度。在32位虚拟机中，一字宽等于四字节，即32bit。</p><p><img src="/images/post-Synchronized-Summary/20181103203445.jpg" alt=""></p><p>Java对象头里的Mark Word里默认存储对象的HashCode，分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下：</p><p><img src="/images/post-Synchronized-Summary/20181103203925.jpg" alt=""></p><p>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据：</p><p><img src="/images/post-Synchronized-Summary/20181103204047.jpg" alt=""></p><p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p><p><img src="/images/post-Synchronized-Summary/20181103204423.jpg" alt="">        </p><h3 id="Synchronized同步方法底层原理"><a href="#Synchronized同步方法底层原理" class="headerlink" title="Synchronized同步方法底层原理"></a>Synchronized同步方法底层原理</h3><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。</p><h3 id="Synchronized同步代码块底层原理"><a href="#Synchronized同步代码块底层原理" class="headerlink" title="Synchronized同步代码块底层原理"></a>Synchronized同步代码块底层原理</h3><p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><h2 id="实例对象锁的线程安全"><a href="#实例对象锁的线程安全" class="headerlink" title="实例对象锁的线程安全"></a>实例对象锁的线程安全</h2><p>当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class AccountingSyncBad implements Runnable&#123;</span><br><span class="line">    static int i=0;</span><br><span class="line">    public synchronized void increase()&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int j=0;j&lt;1000000;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t1=new Thread(new AccountingSyncBad());</span><br><span class="line">        //new新实例</span><br><span class="line">        Thread t2=new Thread(new AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。</p><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。<br><br><br>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p><p><img src="/images/post-Synchronized-Summary/20181103204723.jpg" alt="">      </p><h4 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h4><p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><p><img src="/images/post-Synchronized-Summary/20181103234923.jpg" alt="">  </p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><p><img src="/images/post-Synchronized-Summary/20181103235211.jpg" alt="">  </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>方腾飞：《Java并发编程的艺术》</li><li><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基本数据结构-Dict</title>
      <link href="/2018/11/03/Redis-DataStructure-3-Dict/"/>
      <url>/2018/11/03/Redis-DataStructure-3-Dict/</url>
      
        <content type="html"><![CDATA[<h2 id="Dict简介"><a href="#Dict简介" class="headerlink" title="Dict简介"></a>Dict简介</h2><p>字典（dict）是Redis一个重要的基础数据结构，它是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。比如Redis的数据库就是使用字典来作为底层实现的，对数据的增删查改操作都是构建在对字典的操作之上，又比如，一个Redis hash结构，当它的field较多时，便会采用dict来存储。再比如，<strong>Redis配合使用dict和skiplist来共同维护一个sorted set。</strong><br><br><br>字典经常作为一种数据结构内置在很多高级的编程语言里，但Redis的实现所使用的C语言中并没有内置这种数据结构，因此<strong>Redis构建了自己的字典实现</strong>。</p><h2 id="Dict的双数组哈希表"><a href="#Dict的双数组哈希表" class="headerlink" title="Dict的双数组哈希表"></a>Dict的双数组哈希表</h2><p>Redis中的字典由dict.h/dict结构表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privatedata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure></p><p>其中ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只用于对ht[0]哈希表进行rehash时。<br><br>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p><p><img src="/images/post-Redis-DataStructure-3-Dict/20181103132847.jpg" alt=""></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>Redis计算哈希值和索引值的方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键key的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希值的 sizemark 属性和和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同，ht[x]可以是ht[<span class="number">0</span>]或者ht[<span class="number">1</span>]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemark;</span><br></pre></td></tr></table></figure></p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p><h2 id="键冲突"><a href="#键冲突" class="headerlink" title="键冲突"></a>键冲突</h2><p>键冲突解决方法是链地址法（拉链法），与Java里的hashmap一样使用单向链表把同一个索引上的多个节点连接起来。<br>因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是把新节点添加到链表的表头位置（复杂度为O(1)），排在其它已有节点的前面。</p><h2 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h2><p>哈希表的扩展与收缩是通过执行rehash（重新散列）操作来完成，操作步骤如下：</p><ol><li>空间分配：<br>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）:</li></ol><ul><li>如果是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2ⁿ（2的n次幂）。</li><li>如果是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2ⁿ。</li></ul><ol start="2"><li>rehash：<br>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>替换：<br>当ht[0]包含的所有键值对都迁移到ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：<br>1) 没在执行BGSAVE命令或者BGREWRITEAOF命令，而哈希表的负载因子≥1。<br>2) 有在执行BGSAVE命令或者BGREWRITEAOF命令,并且哈希表的负载因子≥0.5。</p><pre><code>负载因子计算为：load_factor = ht[0].used / ht[0].size;</code></pre><p>负载因子＜0.1时，进行收缩操作。</p><h2 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h2><p>Redis的扩展或收缩需要把ht[0]所有键值对rehash到ht[1]里，这个动作并不是一次性、集中式完成的，而是分多次、渐进式完成的。<br>这么做的原因是，当哈希表数据量庞大到一定量级时，一次性rehash操作会带来庞大的计算量，这样可能会导致服务器在一段时间内停止服务。<br>以下是渐进式rehash的详细步骤：<br>1) 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。<br>2) 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示工作正式开始。<br>3) 在rehash进行期间，每次对字典执行增删改查操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成之后，程序将rehashidx属性的值增1。<br>4) 随着字典操作的不断执行，最终在某个时间节点上，ht[0]的所有键值对都会到了ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作完成。</p><p><strong><br>因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以期间的增删查改操作都会在两个表上进行，例如查找操作时，先会在ht[0]里查找，如果没找到，再查ht[1]，诸如此类。增加操作时，那么新添加的键值对一律会被保存到ht[1]里，而ht[0]则不进行添加，保证了ht[0]包含的键值对只减不增，并随着rehash操作的执行完毕而最终变成空表。<br></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基本数据结构-SkipList</title>
      <link href="/2018/10/26/Redis-DataStructure-2-SkipList/"/>
      <url>/2018/10/26/Redis-DataStructure-2-SkipList/</url>
      
        <content type="html"><![CDATA[<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>有序集合键（sorted set）提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。Redis使用跳跃表（skipList）作为sorted set的底层实现之一，如果一个sorted set包含的元素数量比较多，又或者sorted set中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为sorted set的底层实现。</p><p>跳跃表是一种有序数据结构，能支持平均O(logN)、最坏O(N)复杂度的节点查找，在大部分情况下，跳跃表的效率可以和平衡树相媲美，所以不少程序都使用跳跃表来替代平衡树。</p><h2 id="sorted-set的数据结构"><a href="#sorted-set的数据结构" class="headerlink" title="sorted set的数据结构"></a>sorted set的数据结构</h2><p>有序集合（sorted set）的数据结构底层实现就是跳跃表+字典，如图：<br><img src="/images/post-Redis-DataStructure-2-SkipList/20181031030619.jpg" alt=""></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181031030813.jpg" alt=""></p><h2 id="跳跃表的数据结构"><a href="#跳跃表的数据结构" class="headerlink" title="跳跃表的数据结构"></a>跳跃表的数据结构</h2><p>一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。</p><p>skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p><p>下面我们从头分析一个要求有序的线性结构的查找元素及插入新元素存在的性能问题。</p><p>最容易表达线性结构的自然是数组和链表。可是，无论是数组还是链表，在插入新元素的时候，都会存在性能问题。</p><p> 如果使用数组，插入新元素的方式如下：<br></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026023319.jpg" alt=""></p><p>如果要插入一个值是3的元素，首先要知道这个元素应该插入的位置。使用二分查找可以最快定位，这一步时间复杂度是O（logN）。<br></p><p>插入过程中，原数组中所有大于3的元素都要右移，这一步时间复杂度是O（N）。所以总体时间复杂度是O（N）。<br></p><p> 如果使用链表，插入新元素的方式如下：<br></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026024211.jpg" alt=""></p><p>如果要插入一个值是3的元素，首先要知道这个元素应该插入的位置。链表无法使用二分查找，只能和原链表中的节点逐一比较大小来确定位置。这一步的时间复杂度是O（N）。<br></p><p>插入的过程倒是很容易，直接改变节点指针的目标，时间复杂度O（1）。因此总体的时间复杂度也是O（N）。<br></p><p>这对于拥有几十万元素的集合来说，这两种方法显然都太慢了。<br></p><p>问题来了，既然数组也不行，链表也不想，那要用什么结构才好？<br></p><p>我们可以利用索引的思想，提取出链表中的部分关键节点。<br></p><p>比如给定一个长度是7的有序链表，节点值依次是1→2→3→5→6→7→8。那么我们可以取出所有奇数值的节点作为关键字。<br><br></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026024723.jpg" alt=""></p><p>此时如果要插入一个值是4的新节点，不再需要和原节点8,7,6,5,3逐一比较，只需要比较关键节点7,5,3 <br></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026024910.jpg" alt=""></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026024923.jpg" alt=""></p><p>确定了新节点在关键节点中的位置（3和5之间），就可以回到原链表，迅速定位到对应的位置插入（同样3和5之间）</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026025910.jpg" alt=""></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026030000.jpg" alt=""></p><p>当链表中有1W设置10W个节点，优化效果会很明显，比较次数就整整减少了一半！但是这样的做法只是增加了50%的额外空间，却换来了一倍的性能提高。<br></p><p>不过我们可以进一步思考，既然已经提取了一层关键节点作为索引，那我们为何不能从索引中进一步提取，再提取一层索引的索引呢？</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026030404.jpg" alt=""></p><p>于是乎，我们有了2级索引之后，新的节点可以先和2级索引比较，确定大体范围；然后再和1级索引比较；最后再回到原链表，找到并插入对应位置。<br><br></p><p>当节点很多的时候，比较次数会减少到原来的1/4，如是者，如果我们再继续往上提取更高层的索引，保证每一层是上一层节点的一半，一直到同一层只有两个节点（因为只有一个节点没有比较的意义），那么这样一个多层链表结构，便是我们的跳跃表。</p><p>那么，跳跃表的介绍引子至此已告一段落，下面是一个正儿八经的跳跃表的概念的介绍：<br><br></p><p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026031604.jpg" alt=""></p><p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。<br><br></p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026031812.jpg" alt=""></p><p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026031927.jpg" alt=""></p><ul><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ul><p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。<br></p><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026032038.jpg" alt=""></p><p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。<br></p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p><p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程:<br></p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026032227.jpg" alt=""></p><p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p><p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><img src="/images/post-Redis-DataStructure-2-SkipList/20181026032425.jpg" alt=""></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p><p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p><p>但是，如果你是第一次接触skiplist，那么一定会产生一个疑问：节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？为了回答这个疑问，我们需要分析skiplist的统计性能。</p><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p><p>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</p><p>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</p><p>节点最大的层数不允许超过一个最大值，记为MaxLevel。</p><p>这个计算随机层数的伪码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    level := 1</span><br><span class="line">    // random()返回一个[0...1)的随机数</span><br><span class="line">    while random() &lt; p and level &lt; MaxLevel do</span><br><span class="line">        level := level + 1</span><br><span class="line">    return level</span><br></pre></td></tr></table></figure><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><h2 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h2><ul><li><p>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</p></li><li><p>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p></li><li><p>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p></li><li><p>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p></li><li><p>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</p></li><li><p>从算法实现难度上来比较，skiplist比平衡树要简单得多。</p></li></ul><h2 id="Redis中的sorted-set"><a href="#Redis中的sorted-set" class="headerlink" title="Redis中的sorted set"></a>Redis中的sorted set</h2><p>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p><p>当数据较少时，sorted set是由一个ziplist来实现的。</p><p>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</p><p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。在本系列前面关于ziplist的文章里，我们介绍过，ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p><p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p><p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p><p>在redis.conf中的ADVANCED CONFIG部分的两个Redis配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure></p><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p><p>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。</p><p>当sorted set中插入的任意一个数据的长度超过了64的时候。</p><p>最后，zset结构的代码定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></p><h2 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h2><p>在前面我们对于skiplist和平衡树、哈希表的比较中，其实已经不难看出Redis里使用skiplist而不用平衡树的原因了。现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p><p>There are a few reasons:</p><ol><li><p>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</p></li><li><p>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p></li><li><p>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p></li></ol><p>这段话原文出处：</p><p><a href="https://news.ycombinator.com/item?id=1171423" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=1171423</a><br>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>死锁</title>
      <link href="/2018/10/21/dead-lock/"/>
      <url>/2018/10/21/dead-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="“死锁”的含义"><a href="#“死锁”的含义" class="headerlink" title="“死锁”的含义"></a>“死锁”的含义</h2><p>所谓死锁： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h2 id="Java代码举例"><a href="#Java代码举例" class="headerlink" title="Java代码举例"></a>Java代码举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deadlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取o1对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>( o1 ) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println( <span class="string">"l1 lock o1"</span> );</span><br><span class="line">                                <span class="comment">// 获取o1后先等一会儿，让Lock2有足够的时间锁住o2</span></span><br><span class="line">Thread.sleep( <span class="number">1000</span> );</span><br><span class="line"><span class="comment">// 接着获取o2对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>( o2 ) &#123;</span><br><span class="line">System.out.println( <span class="string">"l1 lock o2"</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取o2对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>( o2 ) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println( <span class="string">"l2 lock o2"</span> );</span><br><span class="line">                                <span class="comment">// 获取o2后先等一会儿，让Lock1有足够的时间锁住o1</span></span><br><span class="line">Thread.sleep( <span class="number">1000</span> ); </span><br><span class="line"><span class="comment">// 接着获取o1对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>( o1 ) &#123;</span><br><span class="line">System.out.println( <span class="string">"l2 lock o1"</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">Deadlock lock = <span class="keyword">new</span> Deadlock();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock1();</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock2();</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个对象，两条线程，用synchronized锁住对象，线程1先锁对象1后锁对象2，线程2先锁对象2后锁对象1。假设线程1先锁对象1，然后休眠1秒，线程锁对象2，之后线程1就没法锁对象2，线程2也没法锁住对象1，双方都在等待对方释放自己在等待的锁。</p><h2 id="“死锁”产生的原因及四个必要条件"><a href="#“死锁”产生的原因及四个必要条件" class="headerlink" title="“死锁”产生的原因及四个必要条件"></a>“死锁”产生的原因及四个必要条件</h2><h3 id="“死锁”的原因可归结为"><a href="#“死锁”的原因可归结为" class="headerlink" title="“死锁”的原因可归结为"></a>“死锁”的原因可归结为</h3><ol><li><p>竞争资源。当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足进程的需要时，会引起诸进程的竞争而产生死锁。</p></li><li><p>进程间推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。</p></li></ol><h3 id="产生“死锁”的四个必要条件"><a href="#产生“死锁”的四个必要条件" class="headerlink" title="产生“死锁”的四个必要条件"></a>产生“死锁”的四个必要条件</h3><ul><li><p>互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；</p></li><li><p>持有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但没有释放该资源，而且还可以继续请求更多资源；</p></li><li><p>不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；</p></li><li><p>环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。</p></li></ul><h3 id="结合代码例子理解“死锁”的产生"><a href="#结合代码例子理解“死锁”的产生" class="headerlink" title="结合代码例子理解“死锁”的产生"></a>结合代码例子理解“死锁”的产生</h3><ul><li>互斥：两条线程各自占有的锁</li><li>持有：线程1持有线程2想要获得的锁1，线程2持有线程1想要的锁2，双方都没有 释放各自占有的对象锁，并且继续请求对方占有的锁</li><li>不可剥夺：两条线程得到互斥资源都没法被强行剥夺</li><li>环形等待：T1{O1}→→T2{O2}→→T1{O1}，{}表示被左边的线程占有{}里的资源，→→表示左边线程申请（等待）右边线程释放其占有的资源<br>PS：环形等待可以是多个线程对多个资源的争夺</li></ul><h2 id="“死锁”问题定位"><a href="#“死锁”问题定位" class="headerlink" title="“死锁”问题定位"></a>“死锁”问题定位</h2><h3 id="获取java进程ID"><a href="#获取java进程ID" class="headerlink" title="获取java进程ID"></a>获取java进程ID</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">"java"</span></span><br></pre></td></tr></table></figure><h3 id="用jstack看进程堆栈"><a href="#用jstack看进程堆栈" class="headerlink" title="用jstack看进程堆栈"></a>用jstack看进程堆栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换进程ID（pid）</span></span><br><span class="line">jstack -l &#123;pid&#125; | grep -A50 -B10 <span class="string">"deadlock"</span></span><br></pre></td></tr></table></figure><p><img src="/images/post-dead-lock/20181021190116.jpg" alt="Java线程间死锁堆栈"></p><h2 id="“死锁”的预防和解除"><a href="#“死锁”的预防和解除" class="headerlink" title="“死锁”的预防和解除"></a>“死锁”的预防和解除</h2><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁，消除产生死锁的四个必要条件中的任何一个都可以预防和解除死锁。不难看出，在死锁的四个必要条件中，第二、三和四项条件比较容易消除。</p><ol><li><p>静态分配：采用资源静态分配策略（进程资源静态分配方式是指一个进程在建立时就分配了它需要的全部资源），破坏”部分分配”条件；</p></li><li><p>可剥夺：允许进程剥夺使用其他进程占有的资源，从而破坏”不可剥夺”条件；</p></li><li><p>有序分配：采用资源有序分配法，破坏”环路”条件</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yunfenglw/article/details/45950305" target="_blank" rel="noopener">“死锁”四个必要条件的合理解释</a><br><br><br><br></p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基本数据结构-SDS</title>
      <link href="/2018/10/14/Redis-DataStructure-1-String/"/>
      <url>/2018/10/14/Redis-DataStructure-1-String/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>&emsp;&emsp;String是我们最常用的Redis基本数据结构之一。Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。<br>&emsp;&emsp;在Redis里边，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisLog(REDIS_WARNING, &quot;Redis is now ready to exit, bye bye...&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><h3 id="常数级复杂度获取字符串长度"><a href="#常数级复杂度获取字符串长度" class="headerlink" title="常数级复杂度获取字符串长度"></a>常数级复杂度获取字符串长度</h3><p>&emsp;&emsp;C语言使用长度为N+1的字符串来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’<br><br><img src="/images/post-Redis-DataStructure-1-String/20181014173701.jpg" alt="C字符串"><br>&emsp;&emsp;因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须便利整个字符数组，对遇到的每个字符进行技术，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)<br><img src="/images/post-Redis-DataStructure-1-String/20181014180720.jpg" alt="#计算C字符串长度的过程"><br>&emsp;&emsp;和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)，这确保了获取字符串长度的操作不会成为Redis的性能瓶颈。譬如”Redis”的长度为5，程序只需要访问SDS的len属性就可以立即得到长度值为5字节<br><img src="/images/post-Redis-DataStructure-1-String/20181014180419.jpg" alt="#5字节长的SDS"></p><h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>&emsp;&emsp;由于C字符串不记录自身长度，会带来另一个问题，就是容易造成缓冲区溢出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *dest, const char *src)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;假定用户在执行strcat函数时，已经为dest分配了足够多的内存，则可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。<br>&emsp;&emsp;举个例子，假设程序里有两个在内存中紧邻着的C字符串s1和s2，其中s1保存了字符串”Redis”，而s2则保存了字符串”MongoDB”，如图所示：<br><img src="/images/post-Redis-DataStructure-1-String/20181014183933.jpg" alt="在内存中紧邻的两个C字符串"></p><p>&emsp;&emsp;如果此时要通过执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(s1, &quot; Cluster&quot;);</span><br></pre></td></tr></table></figure></p><p>将s1的内容修改为”Redis Cluster”，但如果粗心的他却忘了在执行strcat之前为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2的内容被意外地修改了，如图所示：<br><img src="/images/post-Redis-DataStructure-1-String/20181014184447.jpg" alt="#s1的内容溢出到了s2所在的位置上"></p><p>&emsp;&emsp;SDS的空间分配策略则完全杜绝了发生这种情况的可能性：当SDS API需要对SDS的内容进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动把SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现上述的缓冲区溢出问题。</p><h3 id="减少修改字符串时带来的内容重分配次数"><a href="#减少修改字符串时带来的内容重分配次数" class="headerlink" title="减少修改字符串时带来的内容重分配次数"></a>减少修改字符串时带来的内容重分配次数</h3><p>&emsp;&emsp;因为C字符串并不记录自身的长度，所以一个C字符串的底层实现总是额外的多出一个字符空间用于保存空字符。因为C字符串的长度和底层数组长度之间存在着这种关联性，所以每次增长或缩短一个C字符串，都总会在保存这个C字符串的数组时引起一次内存重分配操作</p><p>&emsp;&emsp;而因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作：</p><ul><li>在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的，但Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是这个操作的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响</li></ul><p>&emsp;&emsp;为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数加1，数组里边可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录<br>&emsp;&emsp;通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略：</p><ol><li><p>空间预分配<br>&emsp;&emsp;空间预分配用于优化SDS的字符串增长操作：利用额外的未使用空间进行预分配以减少内存的频繁分配，这一点类似Java中的ArrayList。<br>&emsp;&emsp;当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。而字符串最大长度为 512M。<br>譬如，假如SDS进行修改后变为13字节（小于1MB），那么此时SDS的buf数组的实际长度将变成13+13+1=27字节（额外的1字节用于保存空字符）。假如SDS进行修改后变为2MB（大于等于1MB），则程序将会分配1MB的未使用空间，也就是说，SDS的buf数组的实际长度将为2MB + 1MB + 1byte。</p></li><li><p>惰性空间释放<br>&emsp;&emsp;当要缩短SDS保存的字符串时，程序并不立即使用内存充分配来回收缩短后多出来的字节，而是使用表头的free成员将这些字节记录起来以备用。</p></li></ol><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>&emsp;&emsp;SDS是二进制安全的，它可以存储任意二进制数据，因为SDS使用len属性的值而不是像C语言字符串那样以空字符（‘\0’）来标识字符串结束。</p><p>&emsp;&emsp;因为传统C字符串符合某种编码（比如ASCII），字符串不仅末尾，就连字符串里的内容也不能包含标记着结束的字符。如ASCII这种编码的操作的特点就是：遇零则止。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片、音频、视频等二进制文件，操作文件时就被截断了。</p><h3 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h3><p>&emsp;&emsp;虽然SDS的API都是二进制安全的，但它们一样遵循C字符串结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数，避免不必要的代码重复。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/post-Redis-DataStructure-1-String/20181014212907.jpg" alt="C字符串与SDS之间的区别"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo添加搜索功能</title>
      <link href="/2018/10/14/Hexo-Search/"/>
      <url>/2018/10/14/Hexo-Search/</url>
      
        <content type="html"><![CDATA[<p>本文旨在记录站主基于hexo-generator-search插件实现本站的站内文章搜索功能</p><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p><ol><br>  <li>基于hexo-generator-search生成全文内容索引xml文件</li><br>  <li>利用jQ.ajax请求xml文件并解析</li><br>  <li>jQ搜索关键字内容匹配xml内容</li><br></ol><br><br>主要的部分还是插件写的好，对应的解析函数也是改造插件作者的，网上一搜一大堆此类文章，本文仅仅意在记录本站使用该插件实现搜索的过程</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-generator-search</span><br></pre></td></tr></table></figure><p>这个插件可以生成供搜索的索引数据，生成后的xml文件保存在自己站内目录，可以通过 <a href="http://localhost:4000/search.xml" target="_blank" rel="noopener">http://localhost:4000/search.xml</a> 查看</p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>在hexo根目录底下的_config.xml里加入以下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  #field: post, page or all（3个可选参数）</span><br></pre></td></tr></table></figure></p><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> performLocalSearch = <span class="function"><span class="keyword">function</span>(<span class="params">datas,keywords</span>)</span>&#123;</span><br><span class="line"><span class="comment">// perform local searching</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'&lt;ul class="search-result-list"&gt;'</span>;</span><br><span class="line">datas.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> content_index = [];</span><br><span class="line"><span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line"><span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>).toLowerCase();</span><br><span class="line"><span class="keyword">var</span> data_url = <span class="string">"/"</span> + data.url;</span><br><span class="line"><span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// only match artiles with not empty titles and contents</span></span><br><span class="line"><span class="keyword">if</span>(data_title != <span class="string">''</span> &amp;&amp; data_content != <span class="string">''</span>) &#123;</span><br><span class="line">keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">index_title = data_title.indexOf(keyword);</span><br><span class="line">index_content = data_content.indexOf(keyword);</span><br><span class="line"><span class="keyword">if</span>( index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span> )&#123;</span><br><span class="line">isMatch = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">index_content = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">first_occur = index_content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// show search results</span></span><br><span class="line"><span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">str += <span class="string">'&lt;li&gt;&lt;a href="'</span>+ data_url +<span class="string">'" class="search-result-title" target="_blank"&gt;'</span>+ <span class="string">'&gt; '</span> + data_title +<span class="string">'&lt;/a&gt;'</span>;</span><br><span class="line"><span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// cut out characters</span></span><br><span class="line"><span class="keyword">var</span> start = first_occur - <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> end = first_occur + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span>(start &lt; <span class="number">0</span>)&#123;</span><br><span class="line">start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">end = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(end &gt; content.length)&#123;</span><br><span class="line">end = content.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> match_content = content.substr(start, end); </span><br><span class="line"><span class="comment">// highlight all keywords</span></span><br><span class="line">keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">match_content = match_content.replace(regS, <span class="string">'&lt;em class=\"search-keyword\"&gt;'</span>+keyword+<span class="string">'&lt;/em&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">str += <span class="string">'&lt;p class=\"search-result\"&gt;'</span> + match_content +<span class="string">'...&lt;/p&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Search入口功能函数"><a href="#Search入口功能函数" class="headerlink" title="Search入口功能函数"></a>Search入口功能函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: path,</span><br><span class="line">dataType: <span class="string">"xml"</span>,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params"> xmlResponse </span>) </span>&#123;</span><br><span class="line"><span class="comment">// get the contents from search data</span></span><br><span class="line"><span class="keyword">var</span> datas = $( <span class="string">"entry"</span>, xmlResponse ).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">title: $( <span class="string">"title"</span>, <span class="keyword">this</span> ).text(),</span><br><span class="line">content: $(<span class="string">"content"</span>,<span class="keyword">this</span>).text(),</span><br><span class="line">url: $( <span class="string">"url"</span> , <span class="keyword">this</span>).text()</span><br><span class="line">&#125;;</span><br><span class="line">&#125;).get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $input = $(<span class="string">'#'</span>+search_id);</span><br><span class="line"><span class="keyword">var</span> $resultContent = $(<span class="string">'#'</span>+content_id);</span><br><span class="line"></span><br><span class="line">$input.on(<span class="string">"input propertychange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line"><span class="keyword">if</span>($(<span class="keyword">this</span>).val()==<span class="string">""</span>)&#123;$resultContent.html(<span class="string">''</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">$resultContent.html(performLocalSearch(datas,keywords));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">searchFunc(<span class="string">"/search.xml"</span>,<span class="string">"local-search-input"</span>,<span class="string">"local-search-result"</span>);</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="页面HTML代码"><a href="#页面HTML代码" class="headerlink" title="页面HTML代码"></a>页面HTML代码</h2><p>申明html元素，id、class名字要跟解析函、Search入口功能函数里的代码对上号：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"site_search"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"bar"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> id=<span class="string">"local-search-input"</span> name=<span class="string">"q"</span> results=<span class="string">"0"</span> placeholder=<span class="string">"search my blog..."</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span>/&gt;</span><br><span class="line">  &lt;div id=<span class="string">"local-search-result"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">`</span></span><br></pre></td></tr></table></figure></p><h2 id="样式调整"><a href="#样式调整" class="headerlink" title="样式调整"></a>样式调整</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.search-result-list</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.search-result-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.search-result</span> &#123;</span><br><span class="line">  color=#555;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#4088b8</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-control</span> &#123;</span><br><span class="line"><span class="attribute">padding-left</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bar</span> &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bar</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">350px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">42px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">2px</span> solid <span class="number">#324B4E</span>;</span><br><span class="line"><span class="attribute">background</span>:<span class="number">#F9F0DA</span>;</span><br><span class="line"><span class="attribute">transition</span>:.<span class="number">3s</span> linear;</span><br><span class="line"><span class="attribute">float</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bar</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">420px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程池类比公司经营之道</title>
      <link href="/2018/10/03/Java-ThreadPool-vs-Company/"/>
      <url>/2018/10/03/Java-ThreadPool-vs-Company/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;Java线程池的设计与公司经营的相似之处如果我们查看JDK源码，会发现FixedThreadPool、CachedThreadPool和SingleThreadExecutor都是通过创建一个ThreadPoolExcutor对象来实现的。我们来看一下该ThreadPoolExcutor的构造方法，并对线程池中线程的保留和新建策略做进一步的分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">( <span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一个参数corePoolSize代表了线程池中一定要保持的线程的数量；线程池中的线程可能发生变化，第二个参数maximumPoolSize约束了线程池中所能达到的线程的最大数量；线程有可能一直处于空闲状态，keepAliveTime代表了空闲状态的线程所能存活的时间；TimeUnit代表了时间单位；workQueue是一个缓冲队列，如果任务到达，但是还没有空闲线程可以执行该任务，那么就将该任务置于这个缓冲队列中。为了更加容易理解和记忆线程池这个几个属性的协调工作。我们利用一个精明的老板来比喻线程池。而将线程比作线程中的线程。</p><p>&emsp;&emsp;一个公司必须要保留一定数量的核心员工，不管这些员工是不是老闲着。当然，对于非常抠门的老板，这个数量可能是0，例如CachedThreadPool。核心员工的数量，就是corePoolSize。当一个公司初创时，所有的员工也就是那几个核心员工。当线程池新建时，同样只会创建与corePoolSize数量相当的线程。</p><p>&emsp;&emsp;当新的任务到达时，如果有空闲线程，马上将这些任务分配给空闲线程。如果没有的话，那么，怎么办呢？新建一个线程吗？非也，对于一个精明的老板来说，他只会把这些任务排进任务列表。手下的员工忙完手头的工作，马上就从任务列表的开头位置移出工作，并分配给空闲。这就让每名员工都不停的工作，甚至加班加点。这个任务列表就是workQueue。</p><p>&emsp;&emsp;如果更多的任务涌过来，如同这个公司的业务很好，工作多越堆越多。这个时候，就看任务列表能承受的极限了。有的老板在创立公司的时候，就抱着这种心态——任务列表可以无限长，反正我就招这么多人，客户能等就等，不能等就拉倒。但是，对于很多客户来说，如果等的时间过长，可能就放弃了。具有无限长workQueue的线程池来说，可能同样会导致某些线程等待时间过长，用户任务无响应的问题。</p><p>&emsp;&emsp;但是，如果workQueue不是无限长，那么，其容量总有可能被达到。而新的任务到达时，无法存入workQueue。这如同，这个老板既负责任（不想出现客户无限等待的情况），同时又不想放弃任何一个客户。那么，唯有增加员工数量了，这就如同线程池新建线程。但是，公司总要有个风险评估，不能让员工数量无限增长，于是，maximumPoolSize就代表了员工的最大数量。如同说，在无法两全其美的情形下，即使损失部分客户，也要控制公司的成本风险。线程池同样如此，每个线程都将消耗系统资源，这种消耗必须被控制在一定范围之内。</p><p>&emsp;&emsp;在大量任务涌入，workQueue无法缓存这些任务，而maxinumPoolSize也已经达到时，相当于一个公司达到了它的最大营运能力，就只能拒绝介绍客户任务了。线程池拒绝介绍新的任务，会抛出异常RejectedExecutionException。</p><p>&emsp;&emsp;当然，一个公司的营运既有旺季，也有淡季。上面我们所描述的情形是旺季的营运。如果淡季到了，许多员工都闲下来了。老板就会考虑裁员了。当然，老板不会马上动手，因为不能准确把握旺季和淡季的分界线。他会给空闲员工一个缓冲期，如果这个员工闲了三个月都没工作，那么证明，真的需要裁掉他了。对应到线程池中，keepAliveTime和TimeUnit限制了一个线程的最大空闲时间。相当于一个缓冲期，缓冲期一结束，就会将其销毁，以释放系统资源。当然，这些被“处理”的线程都是核心员工数量之外的，线程池总会保留corePoolSize个线程备用。</p><p>&emsp;&emsp;通过以上描述，我们应该对线程池的运作策略有了一个比较清晰的认识。总结这种策略，主要目的是基于成本考虑——尽量耗用最少的内存，来完成尽可能多的任务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Hello World</title>
      <link href="/2018/10/03/Hexo-First-Guide/"/>
      <url>/2018/10/03/Hexo-First-Guide/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
