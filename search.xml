<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis基本数据结构-String]]></title>
    <url>%2F2018%2F10%2F14%2FRedis-DataStructure-1-String%2F</url>
    <content type="text"><![CDATA[String&emsp;&emsp;String是我们最常用的Redis基本数据结构之一。Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。&emsp;&emsp;在Redis里边，C字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如打印日志：1redisLog(REDIS_WARNING, &quot;Redis is now ready to exit, bye bye...&quot;); SDS与C字符串的区别常数级复杂度获取字符串长度&emsp;&emsp;C语言使用长度为N+1的字符串来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’&emsp;&emsp;因为C字符串并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须便利整个字符数组，对遇到的每个字符进行技术，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)&emsp;&emsp;和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)，这确保了获取字符串长度的操作不会成为Redis的性能瓶颈。譬如”Redis”的长度为5，程序只需要访问SDS的len属性就可以立即得到长度值为5字节 杜绝缓冲区溢出&emsp;&emsp;由于C字符串不记录自身长度，会带来另一个问题，就是容易造成缓冲区溢出。1char *strcat(char *dest, const char *src) &emsp;&emsp;假定用户在执行strcat函数时，已经为dest分配了足够多的内存，则可以容纳src字符串中的所有内容，而一旦这个假定不成立时，就会产生缓冲区溢出。&emsp;&emsp;举个例子，假设程序里有两个在内存中紧邻着的C字符串s1和s2，其中s1保存了字符串”Redis”，而s2则保存了字符串”MongoDB”，如图所示： &emsp;&emsp;如果此时要通过执行：1strcat(s1, &quot; Cluster&quot;); 将s1的内容修改为”Redis Cluster”，但如果粗心的他却忘了在执行strcat之前为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2的内容被意外地修改了，如图所示： &emsp;&emsp;SDS的空间分配策略则完全杜绝了发生这种情况的可能性：当SDS API需要对SDS的内容进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动把SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现上述的缓冲区溢出问题。 减少修改字符串时带来的内容重分配次数&emsp;&emsp;因为C字符串并不记录自身的长度，所以一个C字符串的底层实现总是额外的多出一个字符空间用于保存空字符。因为C字符串的长度和底层数组长度之间存在着这种关联性，所以每次增长或缩短一个C字符串，都总会在保存这个C字符串的数组时引起一次内存重分配操作 &emsp;&emsp;而因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作： 在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都执行一次内存重分配是可以接受的，但Redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是这个操作的时间就会占去修改字符串所用时间的一大部分，如果这种修改频繁地发生的话，可能还会对性能造成影响 &emsp;&emsp;为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数加1，数组里边可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录&emsp;&emsp;通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略： 空间预分配&emsp;&emsp;空间预分配用于优化SDS的字符串增长操作：利用额外的未使用空间进行预分配以减少内存的频繁分配，这一点类似Java中的ArrayList。&emsp;&emsp;当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。而字符串最大长度为 512M。譬如，假如SDS进行修改后变为13字节（小于1MB），那么此时SDS的buf数组的实际长度将变成13+13+1=27字节（额外的1字节用于保存空字符）。假如SDS进行修改后变为2MB（大于等于1MB），则程序将会分配1MB的未使用空间，也就是说，SDS的buf数组的实际长度将为2MB + 1MB + 1byte。 惰性空间释放&emsp;&emsp;当要缩短SDS保存的字符串时，程序并不立即使用内存充分配来回收缩短后多出来的字节，而是使用表头的free成员将这些字节记录起来以备用。 二进制安全&emsp;&emsp;SDS是二进制安全的，它可以存储任意二进制数据，因为SDS使用len属性的值而不是像C语言字符串那样以空字符（‘\0’）来标识字符串结束。 &emsp;&emsp;因为传统C字符串符合某种编码（比如ASCII），字符串不仅末尾，就连字符串里的内容也不能包含标记着结束的字符。如ASCII这种编码的操作的特点就是：遇零则止。即，当读一个字符串时，只要遇到’\0’结尾，就认为到达末尾，就忽略’\0’结尾以后的所有字符。因此，如果传统字符串保存图片、音频、视频等二进制文件，操作文件时就被截断了。 兼容部分C字符串函数&emsp;&emsp;虽然SDS的API都是二进制安全的，但它们一样遵循C字符串结尾的惯例：这些API总会将SDS保存的数据的末尾设置为空字符，并且总会在为buf数组分配空间时多分配一个字节来容纳这个空字符，这是为了让那些保存文本数据的SDS可以重用一部分&lt;string.h&gt;库定义的函数，避免不必要的代码重复。 总结]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Data Structure</tag>
        <tag>String</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加搜索功能]]></title>
    <url>%2F2018%2F10%2F14%2FHexo-Search%2F</url>
    <content type="text"><![CDATA[本文旨在记录站主基于hexo-generator-search插件实现本站的站内文章搜索功能 基本实现原理 基于hexo-generator-search生成全文内容索引xml文件 利用jQ.ajax请求xml文件并解析 jQ搜索关键字内容匹配xml内容主要的部分还是插件写的好，对应的解析函数也是改造插件作者的，网上一搜一大堆此类文章，本文仅仅意在记录本站使用该插件实现搜索的过程 安装插件1npm install --save hexo-generator-search 这个插件可以生成供搜索的索引数据，生成后的xml文件保存在自己站内目录，可以通过 http://localhost:4000/search.xml 查看 插件配置在hexo根目录底下的_config.xml里加入以下配置：1234search: path: search.xml field: post #field: post, page or all（3个可选参数） 解析函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var performLocalSearch = function(datas,keywords)&#123; // perform local searching var str='&lt;ul class="search-result-list"&gt;'; datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,"").toLowerCase(); var data_url = "/" + data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != '' &amp;&amp; data_content != '') &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += '&lt;li&gt;&lt;a href="'+ data_url +'" class="search-result-title" target="_blank"&gt;'+ '&gt; ' + data_title +'&lt;/a&gt;'; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,""); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, "gi"); match_content = match_content.replace(regS, '&lt;em class=\"search-keyword\"&gt;'+keyword+'&lt;/em&gt;'); &#125;); str += '&lt;p class=\"search-result\"&gt;' + match_content +'...&lt;/p&gt;'; &#125; &#125; &#125;); return str; &#125; Search入口功能函数12345678910111213141516171819202122232425262728293031 var searchFunc = function(path, search_id, content_id) &#123; 'use strict'; $.ajax(&#123; url: path, dataType: "xml", success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( "entry", xmlResponse ).map(function() &#123; return &#123; title: $( "title", this ).text(), content: $("content",this).text(), url: $( "url" , this).text() &#125;; &#125;).get(); var $input = $('#'+search_id); var $resultContent = $('#'+content_id); $input.on("input propertychange",function()&#123; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); if($(this).val()=="")&#123;$resultContent.html('');return;&#125; $resultContent.html(performLocalSearch(datas,keywords)); &#125;); &#125; &#125;); &#125; searchFunc("/search.xml","local-search-input","local-search-result");&#125;)(); 页面HTML代码申明html元素，id、class名字要跟解析函、Search入口功能函数里的代码对上号：12345 &lt;div id="site_search" class="bar"&gt; &lt;input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control"/&gt; &lt;div id="local-search-result"&gt;&lt;/div&gt; &lt;/div&gt;` 样式调整1234567891011121314151617181920212223242526272829303132ul.search-result-list &#123; padding-left: 10px;&#125;a.search-result-title &#123; font-weight: bold;&#125;p.search-result &#123; color=#555;&#125;em.search-keyword &#123; border-bottom: 1px dashed #4088b8; font-weight: bold;&#125;.form-control &#123; padding-left:10px; margin-bottom: 10px; &#125;.bar &#123; padding: 10px 10px;&#125;.bar input &#123; width:350px; height: 25px; border-radius:42px; border:2px solid #324B4E; background:#F9F0DA; transition:.3s linear; float:center;&#125;.bar input:focus &#123; width:420px;&#125;]]></content>
      <tags>
        <tag>HEXO</tag>
        <tag>HEXO-GENERATOR-SEARCH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池类比公司经营之道]]></title>
    <url>%2F2018%2F10%2F03%2FJava-ThreadPool-Analogy-Company%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Java线程池的设计与公司经营的相似之处如果我们查看JDK源码，会发现FixedThreadPool、CachedThreadPool和SingleThreadExecutor都是通过创建一个ThreadPoolExcutor对象来实现的。我们来看一下该ThreadPoolExcutor的构造方法，并对线程池中线程的保留和新建策略做进一步的分析。 1public ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &emsp;&emsp;第一个参数corePoolSize代表了线程池中一定要保持的线程的数量；线程池中的线程可能发生变化，第二个参数maximumPoolSize约束了线程池中所能达到的线程的最大数量；线程有可能一直处于空闲状态，keepAliveTime代表了空闲状态的线程所能存活的时间；TimeUnit代表了时间单位；workQueue是一个缓冲队列，如果任务到达，但是还没有空闲线程可以执行该任务，那么就将该任务置于这个缓冲队列中。为了更加容易理解和记忆线程池这个几个属性的协调工作。我们利用一个精明的老板来比喻线程池。而将线程比作线程中的线程。 &emsp;&emsp;一个公司必须要保留一定数量的核心员工，不管这些员工是不是老闲着。当然，对于非常抠门的老板，这个数量可能是0，例如CachedThreadPool。核心员工的数量，就是corePoolSize。当一个公司初创时，所有的员工也就是那几个核心员工。当线程池新建时，同样只会创建与corePoolSize数量相当的线程。 &emsp;&emsp;当新的任务到达时，如果有空闲线程，马上将这些任务分配给空闲线程。如果没有的话，那么，怎么办呢？新建一个线程吗？非也，对于一个精明的老板来说，他只会把这些任务排进任务列表。手下的员工忙完手头的工作，马上就从任务列表的开头位置移出工作，并分配给空闲。这就让每名员工都不停的工作，甚至加班加点。这个任务列表就是workQueue。 &emsp;&emsp;如果更多的任务涌过来，如同这个公司的业务很好，工作多越堆越多。这个时候，就看任务列表能承受的极限了。有的老板在创立公司的时候，就抱着这种心态——任务列表可以无限长，反正我就招这么多人，客户能等就等，不能等就拉倒。但是，对于很多客户来说，如果等的时间过长，可能就放弃了。具有无限长workQueue的线程池来说，可能同样会导致某些线程等待时间过长，用户任务无响应的问题。 &emsp;&emsp;但是，如果workQueue不是无限长，那么，其容量总有可能被达到。而新的任务到达时，无法存入workQueue。这如同，这个老板既负责任（不想出现客户无限等待的情况），同时又不想放弃任何一个客户。那么，唯有增加员工数量了，这就如同线程池新建线程。但是，公司总要有个风险评估，不能让员工数量无限增长，于是，maximumPoolSize就代表了员工的最大数量。如同说，在无法两全其美的情形下，即使损失部分客户，也要控制公司的成本风险。线程池同样如此，每个线程都将消耗系统资源，这种消耗必须被控制在一定范围之内。 &emsp;&emsp;在大量任务涌入，workQueue无法缓存这些任务，而maxinumPoolSize也已经达到时，相当于一个公司达到了它的最大营运能力，就只能拒绝介绍客户任务了。线程池拒绝介绍新的任务，会抛出异常RejectedExecutionException。 &emsp;&emsp;当然，一个公司的营运既有旺季，也有淡季。上面我们所描述的情形是旺季的营运。如果淡季到了，许多员工都闲下来了。老板就会考虑裁员了。当然，老板不会马上动手，因为不能准确把握旺季和淡季的分界线。他会给空闲员工一个缓冲期，如果这个员工闲了三个月都没工作，那么证明，真的需要裁掉他了。对应到线程池中，keepAliveTime和TimeUnit限制了一个线程的最大空闲时间。相当于一个缓冲期，缓冲期一结束，就会将其销毁，以释放系统资源。当然，这些被“处理”的线程都是核心员工数量之外的，线程池总会保留corePoolSize个线程备用。 &emsp;&emsp;通过以上描述，我们应该对线程池的运作策略有了一个比较清晰的认识。总结这种策略，主要目的是基于成本考虑——尽量耗用最少的内存，来完成尽可能多的任务。]]></content>
      <tags>
        <tag>线程池</tag>
        <tag>ThreadPool</tag>
        <tag>corePoolSize</tag>
        <tag>workQueue</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Hello World]]></title>
    <url>%2F2018%2F10%2F03%2FHexo-First-Guide%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
